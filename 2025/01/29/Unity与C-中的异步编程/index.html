<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>Unity与C#中的异步编程 - Furry Monster的博客</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="Unity与C#中的异步编程 - Furry Monster的博客" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="http://furry-monster.github.io/2025/01/29/Unity%E4%B8%8EC-%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2025-01-29T14:06:41.000Z" />
  
  <meta property="og:article:author" content="FurryMonster" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
    <body
        data-color-scheme="dark"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/Furry-Monster" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://codepen.io/Alvin-Young-FurryMonster" target="_blank" aria-label="CodePen">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://patreon.com/FurryMonster" target="_blank" aria-label="Patreon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-mastodon nav-item-icon" href="/" target="_blank" aria-label="Mastodon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-discord nav-item-icon" href="https://discordapp.com/users/1314183151353987094" target="_blank" aria-label="Discord">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        

        
        <div class="date" id="date">
            <span>January</span>
            <span>29,</span>
            <span>2025</span>
        </div>
        

        <h1 class="title">Unity与C#中的异步编程</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://wudaijun.com/2021/11/c-sharp-unity-async-programing/">https://wudaijun.com/2021/11/c-sharp-unity-async-programing/</a></p>
<p><a target="_blank" rel="noopener" href="https://hamidmosalla.com/2018/06/24/what-is-synchronizationcontext/">https://hamidmosalla.com/2018/06/24/what-is-synchronizationcontext/</a></p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>最近写框架的时候，在场景加载的时候偶然发现</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> SceneManager.LoadSceneAsync(_sceneEnum.ToString());</span><br></pre></td></tr></table></figure>

<p>会报错,必须用一个Task包裹起来才能异步加载场景。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Task <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">string</span> sceneName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line">    <span class="keyword">var</span> asyncOperation = SceneManager.LoadSceneAsync(sceneName);</span><br><span class="line">    asyncOperation.completed += _ =&gt; tcs.SetResult(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> tcs.Task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是斗胆请教群里大佬，给出的结论是把Task换成UniTask就行，然后反手甩给我一篇文章，所以这篇博客就到这里结束了（bushi）</p>
<p>好吧，回到正题，Unity协程这方面确实欠缺一些经验，何况Unity的协程是用一种比较特殊的形式实现的，所以有必要稍微总结一下。</p>
<p>在网上找到了一篇不错的文章，内容很全，但是教学语言比较晦涩难懂，所有就用自己的话来记录一遍了喵。</p>
<p>Unity的协程是通过C#枚举器实现的，那这里就不得不先提一下<strong>yield语句</strong>了</p>
<h2 id="C-yield语句"><a href="#C-yield语句" class="headerlink" title="C# yield语句"></a>C# yield语句</h2><p>先来看这段代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">TestYield</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> a+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IEnumerator&lt;<span class="built_in">int</span>&gt; enumerator = TestYield(<span class="number">4</span>).GetEnumerator();</span><br><span class="line">    <span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(enumerator.Current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>程序执行流程:<br>当你运行程序时，传递给 TestYield 的值为 4（偶数）：</p>
<ol>
<li>首先，yield return a + 1 返回 4 + 1 &#x3D; 5，并暂停方法执行。</li>
<li>然后，程序判断 a % 2 &#x3D;&#x3D; 0，由于 4 是偶数，执行 yield break;，终止迭代器的执行。</li>
<li>由于调用 yield break 后方法已停止，之后的 yield return 1; 和 yield return 2; 不会被执行。<br>因此，程序会输出：5。</li>
</ol>
<p>不难看出，yield 语句的作用就是暂停函数执行，并返回一个值，这个值可以被迭代器使用。所以一般用yield来做迭代器，可以这样</p>
<h2 id="Unity-Coroutine（协程）"><a href="#Unity-Coroutine（协程）" class="headerlink" title="Unity Coroutine（协程）"></a>Unity Coroutine（协程）</h2><p>原文这句话比较难懂，我们总结一下它的要点：</p>
<h3 id="1-协程的基本概念"><a href="#1-协程的基本概念" class="headerlink" title="1. 协程的基本概念"></a>1. 协程的基本概念</h3><ul>
<li>协程 是一种特殊的编程方式，它允许你暂停某个方法的执行，过一段时间后再继续执行。这对于需要延时操作或者异步处理的场景很有用。</li>
<li>在Unity中，协程通过 StartCoroutine() 启动，Unity会管理协程的执行，不需要开发者手动控制。</li>
</ul>
<h3 id="2-如何使用Unity的协程"><a href="#2-如何使用Unity的协程" class="headerlink" title="2. 如何使用Unity的协程"></a>2. 如何使用Unity的协程</h3><ul>
<li>在Unity中，协程通常使用 yield return 来暂停执行。例如，你可以使用 yield return new WaitForSeconds(1f); 来暂停协程1秒钟。</li>
<li>Unity的协程是基于 枚举器（IEnumerator） 实现的，Unity会自动管理枚举器的迭代，直到协程完成。</li>
</ul>
<h3 id="3-YieldInstruction"><a href="#3-YieldInstruction" class="headerlink" title="3. YieldInstruction"></a>3. YieldInstruction</h3><ul>
<li>yield return 后面的对象必须是 YieldInstruction 类的实例（比如 WaitForSeconds 或 WaitForEndOfFrame）。这些对象告诉Unity如何等待，直到操作完成。</li>
<li>Unity会不断检查这些对象的状态，一旦它们完成，协程会继续执行。</li>
</ul>
<h3 id="4-Unity协程和JavaScript-Generator的对比"><a href="#4-Unity协程和JavaScript-Generator的对比" class="headerlink" title="4. Unity协程和JavaScript Generator的对比"></a>4. Unity协程和JavaScript Generator的对比</h3><ul>
<li>JavaScript的Generator 和 C#的yield 很像，都是通过暂停和恢复函数来控制异步操作。</li>
<li>Unity的协程使用 yield 进行类似的操作，但它没有JavaScript那样的双向数据传递能力。也就是说，C#的 yield 只能将数据传递给协程，而不能从协程中返回数据。</li>
</ul>
<h3 id="5-协程的生命周期管理"><a href="#5-协程的生命周期管理" class="headerlink" title="5. 协程的生命周期管理"></a>5. 协程的生命周期管理</h3><ul>
<li>在Unity中，协程与 GameObject 绑定。如果一个物体被销毁，相关的协程也会停止。</li>
<li>Unity还支持嵌套协程，即一个协程可以等待另一个协程完成后再继续执行。</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li>Unity的协程实际上是基于C#的 yield 语法，通过使用一些特殊的 YieldInstruction 类来控制异步操作。<br>它提供了一种比传统异步编程更简单的方式来处理延时、定时操作或帧控制。</li>
<li>尽管Unity协程能做很多事情，但它的灵活性和功能不如JavaScript的Generator或其他一些语言中的协程（比如Golang）。</li>
</ul>
<p>总体来说，Unity的协程是非常方便的异步工具，但它并不完全等同于其他语言中的协程。</p>
<h2 id="C-Task"><a href="#C-Task" class="headerlink" title="C# Task"></a>C# Task</h2><p>Task是.NET Framework 4.0引入的新概念，它是一种轻量级的线程，可以用来代表一个异步操作的结果。</p>
<p>原文提供了这段代码:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">111</span>;</span><br><span class="line">    <span class="keyword">var</span> task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;add task, on thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread&#123;0&#125;, task&#123;1&#125; init status: &#123;2&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, task.Id, task.Status);</span><br><span class="line">    task.Start();</span><br><span class="line">    task.ContinueWith((task, arg) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continue with 1, got result: &#123;0&#125;, got arg: &#123;1&#125;, on thread&#123;2&#125;&quot;</span>, task.Result, arg, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;, <span class="string">&quot;Arg1&quot;</span>).</span><br><span class="line">    ContinueWith((task) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continue with 2, on thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    &#125;).Wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// main thread1, task1 init status: Created</span></span><br><span class="line"><span class="comment">// add task, on thread3</span></span><br><span class="line"><span class="comment">// continue with 1, got result: 999, got arg: Arg1, on thread4</span></span><br><span class="line"><span class="comment">// continue with 2, on thread5</span></span><br></pre></td></tr></table></figure>

<p>这段代码我觉得比较好理解，体现了Task的几个特点：</p>
<ol>
<li>任务内部有个简单的状态机，其他线程可通过Task.Status获取任务当前状态</li>
<li>Task.ContinueWith返回值是一个新的Task，可以像JS promise.then一样，以可读性较好的方式(相比回调地狱)书写异步调用链</li>
<li>task.ContinueWith中的回调可以取到到task的返回值，并且可以为其附加额外的参数</li>
<li>task.Wait可以让当前线程同步阻塞等待该任务完成，除此之外，还可以通过Task.WaitAny和Task.WaitAll来等待一个任务数组</li>
<li>在任务执行完成后，通过task.Result可以取得异步任务的返回值，注意，如果此时任务未完成，将会同步阻塞等待任务完成</li>
<li>如果没有指定TaskScheduler，默认的任务调度器只是在线程池中随机选一个线程来执行异步任务和对应回调</li>
</ol>
<p><strong>但是！！！</strong><br>向上面这样使用Task，并不能指定线程，这意味着Task的执行仍然是随机的，这在一些场景下是不合适的。为了解决这个问题，我们需要使用TaskScheduler。</p>
<h2 id="TaskScheduler"><a href="#TaskScheduler" class="headerlink" title="TaskScheduler"></a>TaskScheduler</h2><p>TaskScheduler也是.NET Framework 4.0引入的新概念，它是用来管理任务的执行的。</p>
<p>按照原文的说法，C#中的TaskScheduler有两种：</p>
<ol>
<li><strong>ThreadPoolTaskScheduler</strong>：采用了对象池设计模式，它会在线程池中随机选一个线程来执行异步任务和对应回调。这也是默认的任务调度器。</li>
<li><strong>SynchronizationContextTaskScheduler</strong>：它会在UI线程中执行异步任务和对应回调。是一种为UI提供的上下文线程，写过.NET开发（WPF、WinForm）的应该都比较熟悉。</li>
</ol>
<p>你可以通过 <strong>TaskScheduler</strong> 来控制任务的执行方式。例如，你可以指定一个特殊的调度器让任务在特定的线程上执行，比如 <strong>UI线程（主线程）</strong>。这在GUI编程中非常重要，因为你不能在后台线程直接操作UI控件。</p>
<p>而 <strong>同步上下文</strong> 是一种抽象，提供了在多线程程序中如何切换线程或控制任务执行的方式。例如，在Windows Forms或WPF应用中，UI更新通常必须在UI线程中完成。<strong>SynchronizationContext</strong> 就是用来处理这种情况的。当你通过 <strong>TaskScheduler.FromCurrentSynchronizationContext()</strong> 获取当前的同步上下文时，你就指定了任务在主线程（UI线程）上执行，这对于UI框架特别重要。</p>
<p>所以说白了，同步上下文可以当成 <strong>线程指针</strong> 来使用，它指向当前正在执行的线程。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建并设置当前线程的SynchronizationContext</span></span><br><span class="line">    <span class="comment">// 否则TaskScheduler.FromCurrentSynchronizationContext()调用会触发System.InvalidOperationException异常</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">new</span> SynchronizationContext();</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;main thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;task thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    task.Start();</span><br><span class="line">    task.ContinueWith(t =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;continuewith result: &#123;0&#125;, thread&#123;1&#125;&quot;</span>, t.Result, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    &#125;, TaskScheduler.FromCurrentSynchronizationContext()).Wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// main thread1</span></span><br><span class="line"><span class="comment">// task thread3</span></span><br><span class="line"><span class="comment">// continuewith result: 1, thread4</span></span><br></pre></td></tr></table></figure>

<p>综合起来使用就这上面这样。</p>
<h2 id="C-async-await"><a href="#C-async-await" class="headerlink" title="C# async&#x2F;await"></a>C# async&#x2F;await</h2><p>.NET 4.5引入了async&#x2F;await关键字，它可以让你以同步的方式编写异步代码。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">AsyncTask</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;before await, thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;in task, thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;after await, got result: &#123;0&#125;, thread&#123;1&#125;&quot;</span>, a, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main: before AsyncTask thread&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    <span class="keyword">var</span> r = AsyncTask().Result;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main: after AsyncTask result: &#123;0&#125; thread&#123;1&#125;&quot;</span>, r, Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Main: before AsyncTask thread1</span></span><br><span class="line"><span class="comment">// AsyncTask: before await, thread1</span></span><br><span class="line"><span class="comment">// AsyncTask: in task, thread3</span></span><br><span class="line"><span class="comment">// AsyncTask: after await, got result: 666, thread3</span></span><br><span class="line"><span class="comment">// Main: after AsyncTask result: 667 thread1</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码中，</p>
<p><strong>async</strong> 使得 <strong>AsyncTask</strong> 方法成为一个异步方法，执行到 <strong>await</strong> 时，线程不会被阻塞。</p>
<p><strong>await</strong> 后面的 <strong>Task.Run()</strong> 表示开始一个异步任务，这个任务会在不同的线程上执行（通过线程池），并在完成后将结果返回。</p>
<p>事实上，<strong>async</strong> 修饰一个方法，表示这个方法是异步的，且返回值是一个 <strong>Task</strong> 或 <strong>Task&lt; T &gt;<strong>（也可以是</strong>void</strong>，但最好避免）。<br><strong>await</strong> 用来等待一个异步任务完成，并返回其结果。它会让控制权返回到调用者处，并且不会阻塞线程，直到任务完成。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>async&#x2F;await</strong> 本质上是 <strong>编译器的语法糖</strong>，它通过自动生成一个状态机来管理异步任务的执行流程。</p>
<p>你在代码中写的 <strong>await</strong> 实际上被编译成了状态机的一部分，并且通过回调来控制异步操作的继续执行。</p>
<h4 id="那么编译器是如何工作来实现-async-await-的呢？"><a href="#那么编译器是如何工作来实现-async-await-的呢？" class="headerlink" title="那么编译器是如何工作来实现 async&#x2F;await 的呢？"></a>那么编译器是如何工作来实现 async&#x2F;await 的呢？</h4><p>编译器为每个 async 方法生成一个实现了 <strong>IAsyncStateMachine</strong> 接口的状态机。</p>
<p><strong>await</strong> 后面的任务会生成一个 <strong>Awaiter</strong> 对象，这个对象会被用来管理异步任务的完成和回调。</p>
<p><strong>async</strong> 方法在执行到 <strong>await</strong> 时会停止，直到任务完成，并继续执行剩余代码。</p>
<h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>通过 <strong>状态机</strong>，<strong>async&#x2F;await</strong> 可以控制代码的执行顺序和异步任务的切换。状态机通常根据任务的完成状态来决定是否继续执行下一步操作。</p>
<ul>
<li><p>线程切换：</p>
<ul>
<li>await 会影响当前线程的执行。当一个异步操作在不同线程上完成时，可能会涉及线程的切换。</li>
<li>默认情况下，await 会在任务完成后返回到原线程（这通常是主线程），但是你可以通过 ConfigureAwait(false) 来禁用这一行为，避免不必要的线程切换。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> someTask.ConfigureAwait(<span class="literal">false</span>); <span class="comment">// 不会捕获同步上下文，避免线程切换</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义同步上下文（SynchronizationContext）：</p>
<ul>
<li>如果你在UI线程上执行 await，SynchronizationContext 会捕获当前线程的信息，并确保异步操作在UI线程完成后继续执行。</li>
<li>你可以自定义 SynchronizationContext，例如在测试或非UI线程中执行时。</li>
</ul>
</li>
</ul>
<h3 id="async-await-与-Task-结合使用"><a href="#async-await-与-Task-结合使用" class="headerlink" title="async&#x2F;await 与 Task 结合使用"></a>async&#x2F;await 与 Task 结合使用</h3><p><strong>async&#x2F;await</strong> 结合 <strong>Task</strong> 对象来进行异步编程。你可以使用 <strong>Task.Run()</strong> 来启动后台任务，使用 <strong>await</strong> 等待其结果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为没有async标注，所以编译器不会为该函数生成状态机，但由于该函数返回的是Task，因此可以直接用于await</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F1Async</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要标记了async 就会生成对应状态机，但这里有几点需要注意:</span></span><br><span class="line"><span class="comment">// 1. 如果方法声明为 async，那么可以直接 return 异步操作返回的具体值，不再用创建Task，由编译器通过builder创建Task</span></span><br><span class="line"><span class="comment">// 2. 由于该函数体内没有使用await，整个状态机相当于直接builder.SetResult(2)，其中不涉及异步操作和线程切换(没有await异步切换点)，因此整个过程实际上都是在主线程同步进行的(虽然经过了一层builder.Task封装)</span></span><br><span class="line"><span class="comment">// 3. 编译器也会提示Warning CS1998: This async method lacks &#x27;await&#x27; operators and will run synchronously.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F2Async</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法在Task上套了一层空格子Task，看起来好像和F1Async没区别</span></span><br><span class="line"><span class="comment">// 但实际上，编译器仍然会生成对应的builder和wrapper task，这个wrapper task在原task完成之后，只是做了简单的return操作</span></span><br><span class="line"><span class="comment">// 因此 await F3Async() 实际上可能导致两次线程上下文切换，如果是在UI线程上执行await，用法不当则可能触发&quot;async/await 经典UI线程卡死&quot;场景，因为await会默认捕获SynchronizationContext。这个后面说。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">F3Async</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> Task.Run(() =&gt; &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段注释写的好复杂，看不太懂，总结就是：</p>
<ul>
<li>F1Async：该方法没有async标注，但返回值是Task&lt; int&gt;，因此可以直接用于await。</li>
<li>F2Async：因为没有 await，这个方法会同步执行，尽管它是异步方法。</li>
<li>F3Async：虽然 F3Async 本身是异步的，但因为它内部有一个 await，所以可能会导致两次线程切换。</li>
</ul>
<h3 id="线程切换与-UI-线程卡死"><a href="#线程切换与-UI-线程卡死" class="headerlink" title="线程切换与 UI 线程卡死"></a>线程切换与 UI 线程卡死</h3><p>在UI编程中，如果你使用 <strong>await</strong> 来等待任务并且没有正确地配置同步上下文，可能会导致 UI线程卡死。</p>
<p>如果<strong>await</strong> 捕获了同步上下文，任务可能会在线程池线程中完成，而 <strong>await</strong> 之后的代码又需要在 UI 线程中执行。如果这时 <strong>await</strong> 没有正确地返回到 UI 线程，就会造成卡死。</p>
<p>解决方法：使用 <strong>ConfigureAwait(false)</strong> 来避免 <strong>await</strong> 捕获同步上下文，减少线程上下文切换。</p>
<h3 id="await-与-yield-的区别"><a href="#await-与-yield-的区别" class="headerlink" title="await 与 yield 的区别"></a><strong>await</strong> 与 <strong>yield</strong> 的区别</h3><p>yield 和 await 都生成状态机，但是它们的用途不同：</p>
<ul>
<li>yield 用于生成可枚举的序列（例如迭代器），用于同步操作。</li>
<li>await 用于异步操作，在遇到等待时暂停执行，返回线程，直到任务完成。</li>
</ul>
<h3 id="async-await-与-JavaScript-Generator-异步"><a href="#async-await-与-JavaScript-Generator-异步" class="headerlink" title="async&#x2F;await 与 JavaScript Generator 异步"></a>async&#x2F;await 与 JavaScript Generator 异步</h3><p><strong>async&#x2F;await</strong> 和 <strong>JavaScript Generator</strong> 在某些方面有相似之处。都通过状态机来管理异步流程，但 C# 的 async&#x2F;await 是针对异步操作的高效封装，而 <strong>JS Generator</strong> 是一个更底层的控制流机制，通常需要外部函数来驱动。</p>
<h2 id="Unity-async-await"><a href="#Unity-async-await" class="headerlink" title="Unity async&#x2F;await"></a>Unity async&#x2F;await</h2><p>Unity也引入了C# async&#x2F;await机制，并对其进行了适配:</p>
<ul>
<li>Unity本身也是UI框架，因此它实现了自己的同步上下文<strong>UnitySynchronizationContext</strong>以及主线程的消息泵，如此await的异步委托会默认会回到Unity主线程执行(可通过task.ConfigureAwait配置)</li>
<li>Unity社区提供了针对大部分常见<strong>YieldInstruction</strong>(如WaitForSeconds)，以及其他常用库(如UnityWebRequest、ResourceRequest)的<strong>GetAwaiter</strong>适配(如Unity3dAsyncAwaitUtil)</li>
</ul>
<p>所以，这就是大家所说的，Unity的异步是一种<strong>伪 async&#x2F;await</strong>，它<strong>只是在Unity的上下文</strong>中提供了一种异步编程的机制，并没有真正意义上的异步。</p>
<p>这里我们就按照原文的代码来看：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetAwaiter</span></span><br><span class="line"><span class="comment">// 适配WaitForSeconds类的GetAwaiter方法，通过GetAwaiterReturnVoid返回其Awaiter对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleCoroutineAwaiter <span class="title">GetAwaiter</span>(<span class="params"><span class="keyword">this</span> WaitForSeconds instruction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> GetAwaiterReturnVoid(instruction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetAwaiterReturnVoid</span></span><br><span class="line"><span class="comment">// 创建和返回Awaiter: SimpleCoroutineAwaiter</span></span><br><span class="line"><span class="comment">// 并在Unity主线程执行InstructionWrappers.ReturnVoid(awaiter, instruction)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SimpleCoroutineAwaiter <span class="title">GetAwaiterReturnVoid</span>(<span class="params"><span class="built_in">object</span> instruction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> awaiter = <span class="keyword">new</span> SimpleCoroutineAwaiter();</span><br><span class="line">    RunOnUnityScheduler(() =&gt; AsyncCoroutineRunner.Instance.StartCoroutine(</span><br><span class="line">        InstructionWrappers.ReturnVoid(awaiter, instruction)));</span><br><span class="line">    <span class="keyword">return</span> awaiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InstructionWrappers.ReturnVoid</span></span><br><span class="line"><span class="comment">// 这里其实已经在Unity主线程，所以这里本质是将await最终换回了yield，由Unity来驱动WaitForSeconds的完成</span></span><br><span class="line"><span class="comment">// 只不过yield完成之后，通过awaiter.Complete回到Awaiter.OnCompleted流程去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerator <span class="title">ReturnVoid</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">            SimpleCoroutineAwaiter awaiter, <span class="built_in">object</span> instruction</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// For simple instructions we assume that they don&#x27;t throw exceptions</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> instruction;</span><br><span class="line">    awaiter.Complete(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保Action在Unity主线程上运行</span></span><br><span class="line"><span class="comment">// SyncContextUtil.UnitySynchronizationContext在插件Install的时候就初始化好了</span></span><br><span class="line"><span class="comment">// 如果发现当前已经在Unity主线程，就直接执行Action，无需自己Post自己</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RunOnUnityScheduler</span>(<span class="params">Action action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (SynchronizationContext.Current == SyncContextUtil.UnitySynchronizationContext)</span><br><span class="line">    &#123;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SyncContextUtil.UnitySynchronizationContext.Post(_ =&gt; action(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的Awaiter，它是无返回值的，对应还有一个SimpleCoroutineAwaiter&lt;T&gt;版本</span></span><br><span class="line"><span class="comment">// 它的实现比较简单，就是适配接口，记录委托回调(_continuation)，并在Compele()任务完成时，通过RunOnUnityScheduler封送委托回调</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleCoroutineAwaiter</span> : <span class="title">INotifyCompletion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> _isDone;</span><br><span class="line">    Exception _exception;</span><br><span class="line">    Action _continuation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> IsCompleted</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _isDone; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetResult</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Assert(_isDone);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_exception != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ExceptionDispatchInfo.Capture(_exception).Throw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Complete</span>(<span class="params">Exception e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Assert(!_isDone);</span><br><span class="line"></span><br><span class="line">        _isDone = <span class="literal">true</span>;</span><br><span class="line">        _exception = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always trigger the continuation on the unity thread when awaiting on unity yield</span></span><br><span class="line">        <span class="comment">// instructions</span></span><br><span class="line">        <span class="keyword">if</span> (_continuation != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RunOnUnityScheduler(_continuation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> INotifyCompletion.OnCompleted(Action continuation)</span><br><span class="line">    &#123;</span><br><span class="line">        Assert(_continuation == <span class="literal">null</span>);</span><br><span class="line">        Assert(!_isDone);</span><br><span class="line"></span><br><span class="line">        _continuation = continuation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是WaitForSeconds本身，还是之后的回调委托，其实都是在Unity主线程中执行的，并且结合<strong>RunOnUnityScheduler</strong>的优化，整个过程<strong>既不会创建线程，也不会产生额外的消息投递，只是在yield上加了一层壳子而已</strong>。</p>
<p>总结就是，await&#x2F;async终归只是语法糖，线程的操作还是<strong>通过Awaiter，SynchronizationContext，ConfigureAwait等综合控制</strong>。</p>
<h2 id="UniTask包"><a href="#UniTask包" class="headerlink" title="UniTask包"></a>UniTask包</h2><p>说来说去，咱只是个臭写程序的，还是把这些深奥的东西交给大佬们来实现。光有await&#x2F;async当然是远远不够的，完全没有原生C#的异步编程体验。</p>
<p>所以，社区的大佬开发了UniTask包，它的目的是整合Coroutine的轻量、Task的并发、async&#x2F;await的易用于一体，为开发者提供高性能、可并发、易使用的接口。</p>
<p>提供的功能包括但不限于：</p>
<ul>
<li>基于值类型的 UniTask 和自定义的 AsyncMethodBuilder 来实现0GC</li>
<li>使所有 Unity 的 AsyncOperations 和 Coroutines 可等待 (类似Unity3dAsyncAwaitUtil的适配)</li>
<li>基于 PlayerLoop 的任务(UniTask.Yield, UniTask.Delay, UniTask.DelayFrame…)可以替代所有协程操作</li>
<li>对 MonoBehaviour 消息事件和 uGUI 事件进行 可等待&#x2F;异步枚举 拓展<br>与C#原生 Task&#x2F;ValueTask&#x2F;IValueTaskSource 行为高度兼容</li>
<li>…</li>
</ul>
<blockquote>
<p>UniTask将<strong>Unity单线程异步编程</strong>诸多实践与<strong>async&#x2F;await异步编程模型</strong>有机整合，并对Unity Coroutine与C# Task的诸多痛点进行优化和升级，看起来确实有一统Unity异步编程模型的潜力，应该离整合进Unity官方包也不远了。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大佬说道：</p>
<blockquote>
<p>异步编程模型一直在演进，<strong>看起来写越来越”简单”，可读性越来越”高”，代价是编译器和运行时做了更多的工作</strong>，并且这些工作和原理是作为开发者必须要了解的，以C# async&#x2F;await为例，如果不能充分了解底层原理，就容易引发:</p>
</blockquote>
<ul>
<li>异步回调闭包引用<strong>可变上下文</strong>的问题</li>
<li>async “无栈编程”本身带来的<strong>理解负担和调试难度</strong></li>
<li>代码的线程上下文难以分析，容易引发<strong>并发</strong>安全访问的问题</li>
<li>同一段代码在不同的线程执行可能具有完全不同的行为(SynchronizationContext和ExecuteContext不同)</li>
</ul>
<blockquote>
<p>等问题。语言和框架本身只提供选择，作为使用者的我们，在并发越来越”容易”的同时，保持对原理的理解，才能充分发挥工具的作用(享受上限高的好处，避免下限低的问题)。</p>
</blockquote>

    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by FurryMonster, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
        <p class="tags">
            
            <i class="icon"></i>
            <a href="/tags/Unity/" class="tag">#Unity</a>
        </p>
        
    </div>
    

    <div class="container post-prev-next">
        <a class="next"></a>
        
        <a href="/2025/01/20/Unity%E7%9A%84InputSystem%E4%B8%89%E7%A7%8DBehavior/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">Unity的InputSystem三种Behavior</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/resume" class="item">Resume</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Mx421Q7yE" class="item">ZenlessZone3C</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/Furry-Monster/YouOnlyLockOncev1.0" class="item">YouOnlyLockOnce</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/Furry-Monster/SharpDesktop" class="item">SharpDesktop</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/Furry-Monster" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://codepen.io/Alvin-Young-FurryMonster" class="item">CodePen</a>
                
                <a target="_blank" rel="noopener" href="https://patreon.com/FurryMonster" class="item">Patreon</a>
                
                <a href="" class="item">Mastodon</a>
                
                <a target="_blank" rel="noopener" href="https://discordapp.com/users/1314183151353987094" class="item">Discord</a>
                
            </div>
            
        </div>
        <span>&copy; 2025 FurryMonster<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>