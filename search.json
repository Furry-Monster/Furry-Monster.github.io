[{"title":"Unity与C#中的异步编程","url":"/2025/01/29/Unity与C-中的异步编程/","content":"参考文章：\n\n<https://wudaijun.com/2021/11/c-sharp-unity-async-programing/>\n\n<https://hamidmosalla.com/2018/06/24/what-is-synchronizationcontext/>\n\n## Motivation\n\n最近写框架的时候，在场景加载的时候偶然发现\n\n```csharp\nawait SceneManager.LoadSceneAsync(_sceneEnum.ToString());\n```\n\n会报错,必须用一个Task包裹起来才能异步加载场景。\n\n```csharp\nprivate Task LoadSceneAsync(string sceneName)\n{\n    var tcs = new TaskCompletionSource<object>();\n    var asyncOperation = SceneManager.LoadSceneAsync(sceneName);\n    asyncOperation.completed += _ => tcs.SetResult(null);\n    return tcs.Task;\n}\n```\n\n于是斗胆请教群里大佬，给出的结论是把Task换成UniTask就行，然后反手甩给我一篇文章，所以这篇博客就到这里结束了（bushi）\n\n好吧，回到正题，Unity协程这方面确实欠缺一些经验，何况Unity的协程是用一种比较特殊的形式实现的，所以有必要稍微总结一下。\n\n在网上找到了一篇不错的文章，内容很全，但是教学语言比较晦涩难懂，所有就用自己的话来记录一遍了喵。\n\nUnity的协程是通过C#枚举器实现的，那这里就不得不先提一下**yield语句**了\n\n## C# yield语句\n\n先来看这段代码：\n\n```csharp\npublic static IEnumerable<int> TestYield(int a)\n{\n    yield return a+1;\n    if (a % 2 == 0) {\n        yield break;\n    }\n    else {\n        yield return 1;\n    }\n    yield return 2;\n}\nstatic void Main(string[] args)\n{\n    IEnumerator<int> enumerator = TestYield(4).GetEnumerator();\n    while (enumerator.MoveNext())\n    {\n        Console.WriteLine(enumerator.Current);\n    }\n}\n// Output:\n// 5\n```\n\n程序执行流程:\n当你运行程序时，传递给 TestYield 的值为 4（偶数）：\n\n1. 首先，yield return a + 1 返回 4 + 1 = 5，并暂停方法执行。\n2. 然后，程序判断 a % 2 == 0，由于 4 是偶数，执行 yield break;，终止迭代器的执行。\n3. 由于调用 yield break 后方法已停止，之后的 yield return 1; 和 yield return 2; 不会被执行。\n因此，程序会输出：5。\n\n不难看出，yield 语句的作用就是暂停函数执行，并返回一个值，这个值可以被迭代器使用。所以一般用yield来做迭代器，可以这样\n\n## Unity Coroutine（协程）\n\n原文这句话比较难懂，我们总结一下它的要点：\n\n### 1. 协程的基本概念\n\n- 协程 是一种特殊的编程方式，它允许你暂停某个方法的执行，过一段时间后再继续执行。这对于需要延时操作或者异步处理的场景很有用。\n- 在Unity中，协程通过 StartCoroutine() 启动，Unity会管理协程的执行，不需要开发者手动控制。\n\n### 2. 如何使用Unity的协程\n\n- 在Unity中，协程通常使用 yield return 来暂停执行。例如，你可以使用 yield return new WaitForSeconds(1f); 来暂停协程1秒钟。\n- Unity的协程是基于 枚举器（IEnumerator） 实现的，Unity会自动管理枚举器的迭代，直到协程完成。\n\n### 3. YieldInstruction\n\n- yield return 后面的对象必须是 YieldInstruction 类的实例（比如 WaitForSeconds 或 WaitForEndOfFrame）。这些对象告诉Unity如何等待，直到操作完成。\n- Unity会不断检查这些对象的状态，一旦它们完成，协程会继续执行。\n\n### 4. Unity协程和JavaScript Generator的对比\n\n- JavaScript的Generator 和 C#的yield 很像，都是通过暂停和恢复函数来控制异步操作。\n- Unity的协程使用 yield 进行类似的操作，但它没有JavaScript那样的双向数据传递能力。也就是说，C#的 yield 只能将数据传递给协程，而不能从协程中返回数据。\n\n### 5. 协程的生命周期管理\n\n- 在Unity中，协程与 GameObject 绑定。如果一个物体被销毁，相关的协程也会停止。\n- Unity还支持嵌套协程，即一个协程可以等待另一个协程完成后再继续执行。\n\n### 6. 总结\n\n- Unity的协程实际上是基于C#的 yield 语法，通过使用一些特殊的 YieldInstruction 类来控制异步操作。\n它提供了一种比传统异步编程更简单的方式来处理延时、定时操作或帧控制。\n- 尽管Unity协程能做很多事情，但它的灵活性和功能不如JavaScript的Generator或其他一些语言中的协程（比如Golang）。\n\n总体来说，Unity的协程是非常方便的异步工具，但它并不完全等同于其他语言中的协程。\n\n## C# Task\n\nTask是.NET Framework 4.0引入的新概念，它是一种轻量级的线程，可以用来代表一个异步操作的结果。\n\n原文提供了这段代码:\n\n```csharp\nstatic void Main(string[] args) {\n    int a = 888;\n    int b = 111;\n    var task = new Task<int>(() =>\n    {\n        Console.WriteLine(\"add task, on thread{0}\", Thread.CurrentThread.ManagedThreadId);\n        return a + b;\n    });\n    Console.WriteLine(\"main thread{0}, task{1} init status: {2}\", Thread.CurrentThread.ManagedThreadId, task.Id, task.Status);\n    task.Start();\n    task.ContinueWith((task, arg) =>\n    {\n        Console.WriteLine(\"continue with 1, got result: {0}, got arg: {1}, on thread{2}\", task.Result, arg, Thread.CurrentThread.ManagedThreadId);\n    }, \"Arg1\").\n    ContinueWith((task) =>\n    {\n        Console.WriteLine(\"continue with 2, on thread{0}\", Thread.CurrentThread.ManagedThreadId);\n    }).Wait();\n}\n\n// Output:\n// main thread1, task1 init status: Created\n// add task, on thread3\n// continue with 1, got result: 999, got arg: Arg1, on thread4\n// continue with 2, on thread5\n```\n\n这段代码我觉得比较好理解，体现了Task的几个特点：\n\n1. 任务内部有个简单的状态机，其他线程可通过Task.Status获取任务当前状态\n2. Task.ContinueWith返回值是一个新的Task，可以像JS promise.then一样，以可读性较好的方式(相比回调地狱)书写异步调用链\n3. task.ContinueWith中的回调可以取到到task的返回值，并且可以为其附加额外的参数\n4. task.Wait可以让当前线程同步阻塞等待该任务完成，除此之外，还可以通过Task.WaitAny和Task.WaitAll来等待一个任务数组\n5. 在任务执行完成后，通过task.Result可以取得异步任务的返回值，注意，如果此时任务未完成，将会同步阻塞等待任务完成\n6. 如果没有指定TaskScheduler，默认的任务调度器只是在线程池中随机选一个线程来执行异步任务和对应回调\n\n**但是！！！**\n向上面这样使用Task，并不能指定线程，这意味着Task的执行仍然是随机的，这在一些场景下是不合适的。为了解决这个问题，我们需要使用TaskScheduler。\n\n## TaskScheduler\n\nTaskScheduler也是.NET Framework 4.0引入的新概念，它是用来管理任务的执行的。\n\n按照原文的说法，C#中的TaskScheduler有两种：\n\n1. **ThreadPoolTaskScheduler**：采用了对象池设计模式，它会在线程池中随机选一个线程来执行异步任务和对应回调。这也是默认的任务调度器。\n2. **SynchronizationContextTaskScheduler**：它会在UI线程中执行异步任务和对应回调。是一种为UI提供的上下文线程，写过.NET开发（WPF、WinForm）的应该都比较熟悉。\n\n你可以通过 **TaskScheduler** 来控制任务的执行方式。例如，你可以指定一个特殊的调度器让任务在特定的线程上执行，比如 **UI线程（主线程）**。这在GUI编程中非常重要，因为你不能在后台线程直接操作UI控件。\n\n而 **同步上下文** 是一种抽象，提供了在多线程程序中如何切换线程或控制任务执行的方式。例如，在Windows Forms或WPF应用中，UI更新通常必须在UI线程中完成。**SynchronizationContext** 就是用来处理这种情况的。当你通过 **TaskScheduler.FromCurrentSynchronizationContext()** 获取当前的同步上下文时，你就指定了任务在主线程（UI线程）上执行，这对于UI框架特别重要。\n\n所以说白了，同步上下文可以当成 **线程指针** 来使用，它指向当前正在执行的线程。\n\n```csharp\n\nstatic void Main(string[] args) {\n{\n    // 创建并设置当前线程的SynchronizationContext\n    // 否则TaskScheduler.FromCurrentSynchronizationContext()调用会触发System.InvalidOperationException异常\n    var context = new SynchronizationContext();\n    SynchronizationContext.SetSynchronizationContext(context);\n    Console.WriteLine(\"main thread{0}\", Thread.CurrentThread.ManagedThreadId);\n    Task<int> task = new Task<int>(() =>\n    {\n        Console.WriteLine(\"task thread{0}\", Thread.CurrentThread.ManagedThreadId);\n        return 1;\n    });\n    task.Start();\n    task.ContinueWith(t =>\n    {\n        Console.WriteLine(\"continuewith result: {0}, thread{1}\", t.Result, Thread.CurrentThread.ManagedThreadId);\n\n    }, TaskScheduler.FromCurrentSynchronizationContext()).Wait();\n}\n\n// Output:\n// main thread1\n// task thread3\n// continuewith result: 1, thread4\n```\n\n综合起来使用就这上面这样。\n\n## C# async/await\n\n.NET 4.5引入了async/await关键字，它可以让你以同步的方式编写异步代码。\n\n```csharp\npublic static async void AsyncTask()\n{\n    Console.WriteLine(\"before await, thread{0}\", Thread.CurrentThread.ManagedThreadId);\n    var a = await Task.Run(() =>\n    {\n        Thread.Sleep(500);\n        Console.WriteLine(\"in task, thread{0}\", Thread.CurrentThread.ManagedThreadId); \n        return 666;\n    });\n    Console.WriteLine(\"after await, got result: {0}, thread{1}\", a, Thread.CurrentThread.ManagedThreadId);\n}\nstatic void Main(string[] args)\n{\n    Console.WriteLine(\"Main: before AsyncTask thread{0}\", Thread.CurrentThread.ManagedThreadId);\n    var r = AsyncTask().Result;\n    Console.WriteLine(\"Main: after AsyncTask result: {0} thread{1}\", r, Thread.CurrentThread.ManagedThreadId);\n}\n// Output:\n// Main: before AsyncTask thread1\n// AsyncTask: before await, thread1\n// AsyncTask: in task, thread3\n// AsyncTask: after await, got result: 666, thread3\n// Main: after AsyncTask result: 667 thread1\n```\n\n上面这段代码中，\n\n**async** 使得 **AsyncTask** 方法成为一个异步方法，执行到 **await** 时，线程不会被阻塞。\n\n**await** 后面的 **Task.Run()** 表示开始一个异步任务，这个任务会在不同的线程上执行（通过线程池），并在完成后将结果返回。\n\n事实上，**async** 修饰一个方法，表示这个方法是异步的，且返回值是一个 **Task** 或 **Task< T >**（也可以是**void**，但最好避免）。\n**await** 用来等待一个异步任务完成，并返回其结果。它会让控制权返回到调用者处，并且不会阻塞线程，直到任务完成。\n\n### 实现原理\n\n**async/await** 本质上是 **编译器的语法糖**，它通过自动生成一个状态机来管理异步任务的执行流程。\n\n你在代码中写的 **await** 实际上被编译成了状态机的一部分，并且通过回调来控制异步操作的继续执行。\n\n#### 那么编译器是如何工作来实现 async/await 的呢？\n\n编译器为每个 async 方法生成一个实现了 **IAsyncStateMachine** 接口的状态机。\n\n**await** 后面的任务会生成一个 **Awaiter** 对象，这个对象会被用来管理异步任务的完成和回调。\n\n**async** 方法在执行到 **await** 时会停止，直到任务完成，并继续执行剩余代码。\n\n### 线程切换\n\n通过 **状态机**，**async/await** 可以控制代码的执行顺序和异步任务的切换。状态机通常根据任务的完成状态来决定是否继续执行下一步操作。\n\n- 线程切换：\n\n  - await 会影响当前线程的执行。当一个异步操作在不同线程上完成时，可能会涉及线程的切换。\n  - 默认情况下，await 会在任务完成后返回到原线程（这通常是主线程），但是你可以通过 ConfigureAwait(false) 来禁用这一行为，避免不必要的线程切换。\n\n示例：\n\n```csharp\nvar result = await someTask.ConfigureAwait(false); // 不会捕获同步上下文，避免线程切换\n```\n\n- 自定义同步上下文（SynchronizationContext）：\n\n  - 如果你在UI线程上执行 await，SynchronizationContext 会捕获当前线程的信息，并确保异步操作在UI线程完成后继续执行。\n  - 你可以自定义 SynchronizationContext，例如在测试或非UI线程中执行时。\n\n### async/await 与 Task 结合使用\n\n**async/await** 结合 **Task** 对象来进行异步编程。你可以使用 **Task.Run()** 来启动后台任务，使用 **await** 等待其结果。\n\n```csharp\n// 因为没有async标注，所以编译器不会为该函数生成状态机，但由于该函数返回的是Task，因此可以直接用于await\npublic static Task<int> F1Async()\n{\n    return Task.Run(() => { return 2; });\n}\n\n// 只要标记了async 就会生成对应状态机，但这里有几点需要注意:\n// 1. 如果方法声明为 async，那么可以直接 return 异步操作返回的具体值，不再用创建Task，由编译器通过builder创建Task\n// 2. 由于该函数体内没有使用await，整个状态机相当于直接builder.SetResult(2)，其中不涉及异步操作和线程切换(没有await异步切换点)，因此整个过程实际上都是在主线程同步进行的(虽然经过了一层builder.Task封装)\n// 3. 编译器也会提示Warning CS1998: This async method lacks 'await' operators and will run synchronously.\npublic static async Task<int> F2Async()\n{\n    return 2;\n}\n\n// 该方法在Task上套了一层空格子Task，看起来好像和F1Async没区别\n// 但实际上，编译器仍然会生成对应的builder和wrapper task，这个wrapper task在原task完成之后，只是做了简单的return操作\n// 因此 await F3Async() 实际上可能导致两次线程上下文切换，如果是在UI线程上执行await，用法不当则可能触发\"async/await 经典UI线程卡死\"场景，因为await会默认捕获SynchronizationContext。这个后面说。\npublic static async Task<int> F3Async()\n{\n    return await Task.Run(() => { return 2; });\n}\n```\n\n这段注释写的好复杂，看不太懂，总结就是：\n\n- F1Async：该方法没有async标注，但返回值是Task< int>，因此可以直接用于await。\n- F2Async：因为没有 await，这个方法会同步执行，尽管它是异步方法。\n- F3Async：虽然 F3Async 本身是异步的，但因为它内部有一个 await，所以可能会导致两次线程切换。\n\n### 线程切换与 UI 线程卡死\n\n在UI编程中，如果你使用 **await** 来等待任务并且没有正确地配置同步上下文，可能会导致 UI线程卡死。\n\n如果**await** 捕获了同步上下文，任务可能会在线程池线程中完成，而 **await** 之后的代码又需要在 UI 线程中执行。如果这时 **await** 没有正确地返回到 UI 线程，就会造成卡死。\n\n解决方法：使用 **ConfigureAwait(false)** 来避免 **await** 捕获同步上下文，减少线程上下文切换。\n\n### **await** 与 **yield** 的区别\n\nyield 和 await 都生成状态机，但是它们的用途不同：\n\n- yield 用于生成可枚举的序列（例如迭代器），用于同步操作。\n- await 用于异步操作，在遇到等待时暂停执行，返回线程，直到任务完成。\n\n### async/await 与 JavaScript Generator 异步\n\n**async/await** 和 **JavaScript Generator** 在某些方面有相似之处。都通过状态机来管理异步流程，但 C# 的 async/await 是针对异步操作的高效封装，而 **JS Generator** 是一个更底层的控制流机制，通常需要外部函数来驱动。\n\n## Unity async/await\n\nUnity也引入了C# async/await机制，并对其进行了适配:\n\n- Unity本身也是UI框架，因此它实现了自己的同步上下文**UnitySynchronizationContext**以及主线程的消息泵，如此await的异步委托会默认会回到Unity主线程执行(可通过task.ConfigureAwait配置)\n- Unity社区提供了针对大部分常见**YieldInstruction**(如WaitForSeconds)，以及其他常用库(如UnityWebRequest、ResourceRequest)的**GetAwaiter**适配(如Unity3dAsyncAwaitUtil)\n\n所以，这就是大家所说的，Unity的异步是一种**伪 async/await**，它**只是在Unity的上下文**中提供了一种异步编程的机制，并没有真正意义上的异步。\n\n这里我们就按照原文的代码来看：\n\n```csharp\n// GetAwaiter\n// 适配WaitForSeconds类的GetAwaiter方法，通过GetAwaiterReturnVoid返回其Awaiter对象\npublic static SimpleCoroutineAwaiter GetAwaiter(this WaitForSeconds instruction)\n{\n    return GetAwaiterReturnVoid(instruction);\n}\n\n// GetAwaiterReturnVoid\n// 创建和返回Awaiter: SimpleCoroutineAwaiter\n// 并在Unity主线程执行InstructionWrappers.ReturnVoid(awaiter, instruction)\nstatic SimpleCoroutineAwaiter GetAwaiterReturnVoid(object instruction)\n{\n    var awaiter = new SimpleCoroutineAwaiter();\n    RunOnUnityScheduler(() => AsyncCoroutineRunner.Instance.StartCoroutine(\n        InstructionWrappers.ReturnVoid(awaiter, instruction)));\n    return awaiter;\n}\n\n// InstructionWrappers.ReturnVoid\n// 这里其实已经在Unity主线程，所以这里本质是将await最终换回了yield，由Unity来驱动WaitForSeconds的完成\n// 只不过yield完成之后，通过awaiter.Complete回到Awaiter.OnCompleted流程去\npublic static IEnumerator ReturnVoid(\n            SimpleCoroutineAwaiter awaiter, object instruction)\n{\n    // For simple instructions we assume that they don't throw exceptions\n    yield return instruction;\n    awaiter.Complete(null);\n}\n\n// 确保Action在Unity主线程上运行\n// SyncContextUtil.UnitySynchronizationContext在插件Install的时候就初始化好了\n// 如果发现当前已经在Unity主线程，就直接执行Action，无需自己Post自己\nstatic void RunOnUnityScheduler(Action action)\n{\n    if (SynchronizationContext.Current == SyncContextUtil.UnitySynchronizationContext)\n    {\n        action();\n    }\n    else\n    {\n        SyncContextUtil.UnitySynchronizationContext.Post(_ => action(), null);\n    }\n}\n\n// 真正的Awaiter，它是无返回值的，对应还有一个SimpleCoroutineAwaiter<T>版本\n// 它的实现比较简单，就是适配接口，记录委托回调(_continuation)，并在Compele()任务完成时，通过RunOnUnityScheduler封送委托回调\npublic class SimpleCoroutineAwaiter : INotifyCompletion\n{\n    bool _isDone;\n    Exception _exception;\n    Action _continuation;\n\n    public bool IsCompleted\n    {\n        get { return _isDone; }\n    }\n\n    public void GetResult()\n    {\n        Assert(_isDone);\n\n        if (_exception != null)\n        {\n            ExceptionDispatchInfo.Capture(_exception).Throw();\n        }\n    }\n\n    public void Complete(Exception e)\n    {\n        Assert(!_isDone);\n\n        _isDone = true;\n        _exception = e;\n\n        // Always trigger the continuation on the unity thread when awaiting on unity yield\n        // instructions\n        if (_continuation != null)\n        {\n            RunOnUnityScheduler(_continuation);\n        }\n    }\n\n    void INotifyCompletion.OnCompleted(Action continuation)\n    {\n        Assert(_continuation == null);\n        Assert(!_isDone);\n\n        _continuation = continuation;\n    }\n}\n```\n\n不管是WaitForSeconds本身，还是之后的回调委托，其实都是在Unity主线程中执行的，并且结合**RunOnUnityScheduler**的优化，整个过程**既不会创建线程，也不会产生额外的消息投递，只是在yield上加了一层壳子而已**。\n\n总结就是，await/async终归只是语法糖，线程的操作还是**通过Awaiter，SynchronizationContext，ConfigureAwait等综合控制**。\n\n## UniTask包\n\n说来说去，咱只是个臭写程序的，还是把这些深奥的东西交给大佬们来实现。光有await/async当然是远远不够的，完全没有原生C#的异步编程体验。\n\n所以，社区的大佬开发了UniTask包，它的目的是整合Coroutine的轻量、Task的并发、async/await的易用于一体，为开发者提供高性能、可并发、易使用的接口。\n\n提供的功能包括但不限于：\n\n- 基于值类型的 UniTask 和自定义的 AsyncMethodBuilder 来实现0GC\n- 使所有 Unity 的 AsyncOperations 和 Coroutines 可等待 (类似Unity3dAsyncAwaitUtil的适配)\n- 基于 PlayerLoop 的任务(UniTask.Yield, UniTask.Delay, UniTask.DelayFrame…)可以替代所有协程操作\n- 对 MonoBehaviour 消息事件和 uGUI 事件进行 可等待/异步枚举 拓展\n与C#原生 Task/ValueTask/IValueTaskSource 行为高度兼容\n- ...\n\n> UniTask将**Unity单线程异步编程**诸多实践与**async/await异步编程模型**有机整合，并对Unity Coroutine与C# Task的诸多痛点进行优化和升级，看起来确实有一统Unity异步编程模型的潜力，应该离整合进Unity官方包也不远了。\n\n## 总结\n\n大佬说道：\n>异步编程模型一直在演进，**看起来写越来越”简单”，可读性越来越”高”，代价是编译器和运行时做了更多的工作**，并且这些工作和原理是作为开发者必须要了解的，以C# async/await为例，如果不能充分了解底层原理，就容易引发:\n\n- 异步回调闭包引用**可变上下文**的问题\n- async “无栈编程”本身带来的**理解负担和调试难度**\n- 代码的线程上下文难以分析，容易引发**并发**安全访问的问题\n- 同一段代码在不同的线程执行可能具有完全不同的行为(SynchronizationContext和ExecuteContext不同)\n\n>等问题。语言和框架本身只提供选择，作为使用者的我们，在并发越来越”容易”的同时，保持对原理的理解，才能充分发挥工具的作用(享受上限高的好处，避免下限低的问题)。\n","tags":["Unity"]},{"title":"Unity的InputSystem三种Behavior","url":"/2025/01/20/Unity的InputSystem三种Behavior/","content":"# 三类Behavior辨析\n## Send / Broadcast Messages\nPlayerInput.cs类内部使用GameObject.SendMessage()或者GameObject.BroadcastMessage()方法，本质都是使用反射方式实现方法调用的。\n  \n- 这两种Behavior采用约定的方式，当某Action触发时，自动查找当前PlayerInput所属GameObject的 \" On+对应action名 \" 方法，进行方法调用。所以使用时，遵循这种约定，添加 \" On+对应action名 \" 的方法即可。\n- Broadcast Messages 与Send Message的区别就是Broadcast 除了当前GameObject，还会查找所有子对象是否有对应方法，会一并调用。\n- 这种约定的方法名是PlayerInput初始化时进行缓存的：\n```\nvoid CacheMessageNames()\n{\n    if (m_Actions == null)\n        return;\n    if (m_ActionMessageNames != null)\n        m_ActionMessageNames.Clear();\n    else m_ActionMessageNames = new Dictionary<string, string>();\n    foreach (var action in m_Actions)\n    {\n        action.MakeSureIdIsInPlace();\n        var name = CSharpCodeHelpers.MakeTypeName(action.name);\n        m_ActionMessageNames[action.m_Id] = \"On\" + name;\n    }\n}\n```\n\n**特别注意：**\n\n1. Send/Broadcast Messages方式，目前只处理performed或者type为value的canceled的回调，所以对于这两种方式，Button类型Action的按键释放通知是不处理的。\n\n2. 反射对方法名大小写敏感，方法大小写不匹配时方法不触发，但不报异常\n>action name在上面cacheName 时首字母会转成大写，所以写方法时注意，比如action叫fireCube，但方法要写成OnFireCube，写成OnfireCube或者OnFirecube都是无法触发的\n3. 方法可以带InputValue参数，但无参和有参同时存在只会调用首先声明的那一个\n>如果方法名正确，但带错参数会报MissingMethodException，比如你像另两个behavior一样带CallbackContext是不行的。\n```\n//哪个写在前面调用谁\npublic void OnFireCube(InputValue value)\n{\n    Debug.Log(\"父对象触发fire action，value=\" + value.Get<float>());\n}\npublic void OnFireCube()\n{\n    Debug.Log(\"父对象触发fire action\");\n}\n```\n\n## Invoke CSharp Events\n使用原生c#事件方式，利用PlayerInput.onActionTriggered事件间接监听action事件触发：\n\n```\nprivate void Start()\n{\n    var playerInput = GetComponent<PlayerInput>();\n    playerInput.onActionTriggered += context =>\n    {\n        switch (context.action.name)\n        {\n            case \"fireCube\":\n                OnFire(context);\n                break;\n        }\n    };\n}\npublic void OnFire(InputAction.CallbackContext context)\n{\n    switch (context.phase)\n    {\n        case InputActionPhase.Performed:\n            Debug.Log(\"c#Event performed:value=\"+context.ReadValue<float>());\n            break;\n        case InputActionPhase.Canceled:\n            Debug.Log(\"c#Event canceled:value=\"+context.ReadValue<float>());\n            break;\n        case InputActionPhase.Started:\n            Debug.Log(\"c#Event start:value=\"+context.ReadValue<float>());\n            break;\n    }\n}\n\n```\n\n当然你也可以不用PlayerInput的事件，直接用InputSystem、ActionMap或者Action注册回调。\n\n```\nclass MyPlayerInputScript : MonoBehaviour\n{\n    private void Awake()\n    {\n        // 需要访问PlayerInput组件和相关的Action\n        PlayerInput playerInput = GetComponent<PlayerInput>();\n        InputAction hit = playerInput.actions[\"Fire\"];\n        // 手动注册回调函数\n        hit.started += OnFireStarted;\n        hit.performed += OnFirePerformed;\n        hit.canceled += OnFireCanceled;\n    }\n    void OnFireStarted(InputAction.CallbackContext context)\n    {\n        var v = context.ReadValue<float>();\n        Debug.Log(string.Format(\"Fire Started:{0}\", v));\n    }\n    void OnFirePerformed(InputAction.CallbackContext context)\n    {\n        var v = context.ReadValue<float>();\n        Debug.Log(string.Format(\"Fire Performed:{0}\", v));\n    }\n    void OnFireCanceled(InputAction.CallbackContext context)\n    {\n        var v = context.ReadValue<float>();\n        Debug.Log(string.Format(\"Fire Canceled:{0}\", v));\n    }\n}\n\n```\n\n## Invoke Unity Events ⭐\nInvoke Unity Event方式，和原生c#逻辑是类似的，只不过是用UI操作代替code罢了。因为需要UI操作，所以用了Unity Event，在PlayerInput组件引入ActionEvent[] m_ActionEvents即可，Inspector中就会多出Events列表，对ActionAsset中每个action都可以注册一个回调方法，注册的方法是\n1. 前一个候选框选择方法所在的对象（或对象上的任意组件，不能单是脚本！）\n2. 选择方法所在的脚本，并选择此方法\n>这种behavior的回调方法也可以带CallbackContext参数，使用和c#event相同：\n```\npublic void OnFire(InputAction.CallbackContext context)\n{\n    if(context.phase == InputActionPhase.Performed)\n    {\n      Debug.Log(\"c#Event performed:value=\"+context.ReadValue<float>());\n    }\n}\n```\n\n## 三类消息通知方式比较\n- sendMessage / boardcast\n这种方式虽然使用简单，但需要搜索一个潜在的庞大组件列表，以找到那些包含匹配方法的组件，这引入了大量的开销。更糟糕的是，由于它们使用字符串作为方法名称，因此它们使用反射来标识匹配的方法。在这种情况下，反射是在运行时与类型系统交互和修改类型系统的能力，但通过反射调用方法比以正常方式调用方法慢。如果你使用一次或两次反射，这很好，但如果你经常使用，那么这些小的性能影响就会加起来。不仅如此，由于所有这些都发生在运行时，因此根本没有编译时错误检查。这使得方法名称中的拼写错误等小错误更容易需要很长时间才能调试。\n\n- PlayerInput的输入触发通知的本质就是给Action的三个事件performed、canceled、started注册回调，只不过差别在，C#Event需要手动通过代码方式注册，而sendMessage 用的约定、UnityEvent用的UI绑定默认注册罢了。\n\n> 总的来说：sendMessage 最方便，但性能最差、灵活性不佳；UnityEvent最直观，性能一般；C#Event 最灵活、性能最好，但操作稍麻烦。根据需要选择适合的Behavior。","tags":["Unity"]},{"title":"浅析图形渲染空间","url":"/2024/11/16/浅析图形渲染空间/","content":"之前学习Unity的渲染管线的时候，比较少接触空间这方面的知识。现在重新从Unity转向UE的时候，发现空间这部分的知识还是挺重要的，遂开一篇博客记录一下学习历程。\n\n# 坐标空间术语\n\n这部分没啥必要细说，按照UE5的官方文档所言：\n\n> 坐标空间术语包括两方面：**空间** 与 **空间变换**\n\n## 空间\n\n| 虚幻引擎中的坐标空间             | 别名                                                                                                         | 描述                                                                                                                                                                                                                                                        |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Tangent (切线空间)               |                                                                                                              | 为正交坐标系（插值后将发生偏移），可为左手或右手坐标系。<br />TangentToLocal (切线空间到局部空间)变换仅包含旋转变换，<br />因此它是标准正交坐标变换。（可通过转置或求逆进行反变换）。                                                                       |\n| Local (局部空间)                 | Object Space (对象空间)                                                                                      | 为正交坐标系，可为左手或右手坐标系（常用是右手坐标系）。<br />LocalToWorld (局部空间变换到世界空间)变换，<br />非线性变换链的起始变换（如果包含缩放变换）以上及平移变换。                                                                                   |\n| World (世界空间)                 |                                                                                                              | WorldToView (世界空间到视镜像空间)变换仅包含旋转和平移变换，<br />所以View（视图）空间中的坐标和World（世界）空间中的坐标是一样。                                                                                                                           |\n| TranslatedWorld (平移的世界空间) |                                                                                                              | TranslatedWorld (平移的世界空间) = World （世界空间） + PreViewTranslation （在视变换之前进行的平移变换）                                                                                                                                                   |\n| View (观察空间)                  | CameraSpace (相机空间)                                                                                       | 平移矩阵用于从组合变换矩阵中去除浮动相机位置，这提高了移动项点的精确度。<br />ViewToClip (观察空间到剪裁空体)变换包括XY、Y轴上的缩放变换。但不包括Z轴变换(这种变换/缩/偏向中)。<br />可在Z轴上缩放以及平移，通过变换挤紧坐标为空间为ClipSpace（剪裁空间）。 |\n| Clip (裁剪空间)                  | HomogenousCoordinates (齐次坐标系)、<br />PostProjectionSpace (后投影空间)、<br />ProjectionSpace (投影空间) | 以透视投影矩阵形式进行透视的空间坐标。注意剪裁空间中的W和视投影转件的位一样。                                                                                                                                                                               |\n| Screen (屏幕空间)                | OpenGL 的 NormalizedDeviceCoordinates (规格化设备坐标系)                                                     | 在透视投影完成之后：<br />左侧/右侧 -1,1，顶部/底部 1,-1，近/远 0,1 <br />(OpenGL RH需要更改个固定变为 -1,1)                                                                                                                                                |\n| Viewport (视口空间)              | ViewportCoordinates (视口坐标系)、<br />WindowCoordinates (窗口坐标系)                                       | 通常被认为单位：<br />左侧/右侧 0, 0宽度-1，顶部/底部 0, 高度-1                                                                                                                                                                                             |\n\n## 空间变换\n\n空间变换应该始终使用 ***X To Y*** 的命名格式。\n\n**示例：**\n\n* WorldToView\n* TranslatedWorldToView\n* TangentToWorld\n\n# 空间的投影变换\n\n之前在初学Unity的时候，对空间的唯一认知就是确定一个Transform坐标。这次我们从图形学的角度来理解空间。\n\n一个数据表示的三维模型，显示到电脑屏幕的平面上，需要经过如下过程：\n\n```mermaid\nflowchart TD\n    A[模型空间<br>Model/Object/Local Space] --> B[模型变换矩阵<br>Model Matrix]\n    B --> C[世界空间<br>World Space]\n    C --> D[观察变换矩阵<br>View Matrix]\n    D --> E[相机空间<br>Camera Space]\n    E --> F[投影变换矩阵<br>Projection Matrix]\n    F --> G[裁切空间<br>Clip Space]\n    G --> H[屏幕空间<br>Screen Space]\n    B -.-> I[MVP矩阵]\n    D -.-> I\n    F -.-> I\n\n```\n\n这个MVP矩阵，就是用于计算一个集合阶段的顶点变换的矩阵，即：\n\nMVP矩阵 = Projection矩阵 * View矩阵 * Model矩阵\n\n# 几类空间的解释\n\n推荐一个油管上的视频：[View, World, Object, &amp; Tangent Space - Shader Graph Basics - Episode 10](https://www.youtube.com/watch?v=E6Srr-HaicI)\n\n### 模型/物体/本地空间 Model/Object/Local Space\n\n模型/物体/本地，这三类叫法指的是同一空间。模型空间的坐标系原点是模型的原点。X,Y,Z三轴向量的方向和轴单位长度则以模型建模时为标准。\n\n就是旋转模型之后，跟着旋转的那个坐标系。\n\n### 世界空间 World Space\n\n世界空间 是游戏引擎直接使用频率最高的空间。平时在gameplay逻辑代码中获取的物体绝对坐标就是世界空间系下物体的坐标。\n\n也就是旋转模型之后，始终保持原正交的坐标系。\n\n### 相机/观察空间 Camera/View Space\n\n相机/观察空间的坐标系原点和轴向就是相机的位置和旋转轴向。但是有一点特殊，所有空间中只有相机/观察空间是右手坐标系，其余的空间都是左手坐标系。\n\n在UE中的View Space和Camera Space是两个空间，View Space是相对Camera Space的，他在阴影通道的表现和Camera Space略有不同。\n\n### 切线空间 Tangent Space\n\n最抽象的一个空间，在Unity中甚至没有提及，在UE中额外提了一嘴。\n\n切线空间不像其它空间是宏观意义的坐标系。它是对面，点的坐标系。可以理解为每个点都有独立切线坐标系。\n\n![TS](https://pica.zhimg.com/v2-8bd136ffdc67dd344b5092499ab3b2ba_1440w.jpg)\n\n图中红色方向是我们熟悉的法线，准确的说是这个面上某个像素的法线（Normal）。绿色的就是这个法线的切线（Tangent），蓝色的是正切线（Bitangent）。切线就是当前这个像素点的面或者顶点的切线，正切线就是法线和切线的叉乘结果向量，坐标系的3轴两两垂直。\n\n好，那么这玩意有个啥用？\n\n这个时候就要联想到游戏开发上了，模型除了网格，还有贴图啊！为了贴图，法线可就很重要了！所以切线空间就是为了法线而生的！\n\n模型Model的法线表现形式是模型数据在建模软件导出时赋予的，而模型软件在导出的时候不光给出了点面的法线方向，同时还给出了切线方向。而我们通过法线和切线向量的叉乘就得到了垂直于法线和切线构成的面的正切线向量。于是，切线空间坐标系就组装完成了。切线空间和模型空间一样，都是在模型数据决定的。模型空间是宏观的，模型所有点共用一个坐标系。而切线空间是微观的，所有点各自拥有一个坐标系。知道了切线空间的坐标系的构成，那就能实现其它空间和切线空间的转换。\n\n修改法线的意义，在于通过切线空间，我们可以实现在不增加模型顶点数量的情况下，增加模型表面的光照细节；也可以实现面上细节的层次叠加，如岩石上层分布苔藓等。\n\n比如一块平整的石头，它的法线肯定都是一个朝向，如果我通过切线空间修改了法线的方向，就能在视觉上产生坑坑洼洼的效果，尽管这块石头的网格、顶点、贴图都是同一个。说白了也就是通过代码实现更加有意思的效果。\n","tags":["计算机图形学"]},{"title":"一次Avalonia命令绑定Bug","url":"/2024/11/06/一次Avalonia命令绑定Bug/","content":"（~~Avalonia偶遇Command绑定Bug，越过单例限制报错强如怪物，拼尽全力终于战胜~~）\n\n算是开发阶段中第一次吃了单例不加锁的亏，前前后后排查了一整天，给群里大佬问红温了都。。。\n\n简单来说，代码最开始是这样的：\n\n```xml\n<UserControl xmlns=\"https://github.com/avaloniaui\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n             xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n             xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n             xmlns:vm=\"clr-namespace:ItemsPanelMainCommand.ViewModels\"\n             mc:Ignorable=\"d\" d:DesignWidth=\"800\" d:DesignHeight=\"450\"\n             x:Class=\"ItemsPanelMainCommand.Views.MainView\"\n             x:DataType=\"vm:MainViewModel\">\n  <Design.DataContext>\n    <vm:MainViewModel />\n  </Design.DataContext>\n    <ItemsControl ItemsSource=\"{Binding Items}\">\n        <ItemsControl.ItemTemplate>\n            <DataTemplate>\n                <StackPanel Orientation=\"Horizontal\">\n                    <TextBlock Text=\"{Binding Name}\"></TextBlock>\n                    <Button Command=\"{Binding DeleteCommand}\" CommandParameter=\"{Binding}\">删除</Button>\n                </StackPanel>\n            </DataTemplate>\n        </ItemsControl.ItemTemplate>\n    </ItemsControl>\n</UserControl>\n```\n\n事实上，Button绑定Command的时候，DataContext并不是**MainViewModel**而是**Items**，我们需要找到最外层的DataContext。\n\n一般来说，正常情况会这样解决：\n\n```xml\n<Button Command=\"{Binding $parent[ItemsControl].DataContext.DeleteCommand}\" x:CompileBindings=\"False\" CommandParameter=\"{Binding}\">删除-方案1</Button>\n<Button Command=\"{ReflectionBinding $parent[ItemsControl].DataContext.DeleteCommand}\" CommandParameter=\"{Binding}\">删除-方案2</Button>\n<Button Command=\"{Binding $parent[ItemsControl].((vm:MainViewModel)DataContext).DeleteCommand }\" CommandParameter=\"{Binding}\">删除-方案3</Button>\n```\n\n或者这样解决：\n\n```xml\n<Button Command=\"{Binding RelativeSource={RelativeSource AncestorType=UserControl},Path=DataContext.OpenDesktopCommand}\"\n```\n\n但是这次我干了点不一样的，因为之前学习大佬源码的时候，发现可以用一个ViewModelLocator手动进行ViewModel的管理，所以我就自己手搓了一个VMLocator：\n\n```csharp\nusing ReactiveUI;\nusing System.Collections.Generic;\nusing System;\n\nnamespace SharpDesktop.ViewModels;\n\npublic class ViewModelLocator\n{\n    // 单例模式\n    private static ViewModelLocator? _instance;\n\n    public static ViewModelLocator Instance => _instance ??= new ViewModelLocator();\n\n    public ViewModelLocator()\n    {\n        _instance = this;\n        _dic = new Dictionary<Type, ViewModelBase?>();\n    }\n\n    #region 操作\n    /// <summary>\n    /// 初始化\n    /// </summary>\n    /// <param name=\"hostScreen\"> 宿主屏幕 </param>\n    /// <returns> ViewModelLocator 实例 </returns>\n    public ViewModelLocator Init(IScreen hostScreen)\n    {\n        _hostScreen = hostScreen;\n\n        // 注册路由视图模型\n        Instance.RegisterRoutable<DesktopViewModel>(hostScreen)\n                .RegisterRoutable<ResourceViewModel>(hostScreen)\n                .RegisterRoutable<WorkspaceViewModel>(hostScreen)\n                .RegisterRoutable<ToolboxViewModel>(hostScreen)\n                .RegisterRoutable<TerminalViewModel>(hostScreen)\n                .RegisterRoutable<AiViewModel>(hostScreen);\n\n        return Instance;\n    }\n\n    /// <summary>\n    /// 注册视图模型\n    /// </summary>\n    /// <typeparam name=\"TViewModel\"> 视图模型类型 </typeparam>\n    /// <typeparam name=\"TConcrete\"> 视图模型的实例 </typeparam>\n    public ViewModelLocator Register<TViewModel, TConcrete>() where TViewModel : ViewModelBase where TConcrete : TViewModel\n    {\n        var viewModelInstance = Activator.CreateInstance<TConcrete>();\n        _dic[typeof(TViewModel)] = viewModelInstance ?? throw new InvalidOperationException($\"无法创建类型 {typeof(TViewModel).Name} 的实例\");\n        return Instance;\n    }\n\n    /// <summary>\n    ///  注册可路由的视图模型\n    /// </summary>\n    /// <typeparam name=\"TViewModel\"> 视图模型类型 </typeparam>\n    /// <param name=\"hostScreen\"> 宿主屏幕 </param>\n    public ViewModelLocator RegisterRoutable<TViewModel>(IScreen hostScreen) where TViewModel : ViewModelBase\n    {\n        if (hostScreen is null) throw new ArgumentNullException(nameof(hostScreen));\n\n        // 使用反射创建 TViewModel 的实例\n        var viewModelInstance = Activator.CreateInstance(typeof(TViewModel), hostScreen) as TViewModel;\n        _dic[typeof(TViewModel)] = viewModelInstance ?? throw new InvalidOperationException($\"无法创建类型 {typeof(TViewModel).Name} 的实例\");\n\n        return Instance;\n    }\n\n    /// <summary>\n    /// 获取视图模型实例\n    /// </summary>\n    /// <typeparam name=\"TViewModel\"> 视图模型类型 </typeparam>\n    /// <returns> 视图模型实例 </returns>\n    /// <exception cref=\"ArgumentException\"> 未注册视图模型 </exception>\n    public TViewModel GetInstance<TViewModel>() where TViewModel : ViewModelBase\n    {\n        if (_dic.TryGetValue(typeof(TViewModel), out var vm))\n        {\n            return (TViewModel)vm!;\n        }\n\n        throw new ArgumentException($\"未注册{typeof(TViewModel).Name}的视图模型\");\n    }\n\n    /// <summary>\n    /// 判断是否注册了视图模型\n    /// </summary>\n    /// <typeparam name=\"TViewModel\"> 视图模型类型 </typeparam>\n    /// <returns> 是否注册了视图模型 </returns>\n    public bool IsRegistered<TViewModel>() where TViewModel : ViewModelBase\n    {\n        return _dic.ContainsKey(typeof(TViewModel));\n    }\n\n    /// <summary>\n    /// 注销视图模型\n    /// </summary>\n    /// <typeparam name=\"TViewModel\"> 视图模型类型 </typeparam>\n    public ViewModelLocator Unregister<TViewModel>() where TViewModel : ViewModelBase\n    {\n        _dic.Remove(typeof(TViewModel));\n        return Instance;\n    }\n\n    /// <summary>\n    /// 清空所有视图模型\n    /// </summary>\n    public ViewModelLocator Clear()\n    {\n        _dic.Clear();\n        return Instance;\n    }\n\n    /// <summary>\n    /// 尝试获取视图模型\n    /// </summary>\n    /// <param name=\"type\"> 视图模型类型 </param>\n    /// <param name=\"vm\"> 视图模型实例 </param>\n    /// <returns> 是否获取成功 </returns>\n    public bool TryGetViewModel(Type type, out ViewModelBase? vm)\n    {\n        return _dic.TryGetValue(type, out vm);\n    }\n\n    /// <summary>\n    /// 尝试获取视图模型\n    /// </summary>\n    /// <typeparam name=\"TViewModel\"> 视图模型类型 </typeparam>\n    /// <param name=\"vm\"> 视图模型实例 </param>\n    /// <returns> 是否获取成功 </returns>\n    public bool TryGetViewModel<TViewModel>(out TViewModel? vm) where TViewModel : ViewModelBase\n    {\n        if (_dic.TryGetValue(typeof(TViewModel), out var v))\n        {\n            vm = (TViewModel)v!;\n            return true;\n        }\n\n        vm = default;\n        return false;\n    }\n\n    /// <summary>\n    /// 尝试获取视图模型\n    /// </summary>\n    /// <typeparam name=\"TViewModel\"> 视图模型类型 </typeparam>\n    /// <param name=\"vm\"> 视图模型实例 </param>\n    /// <returns> 是否获取成功 </returns>\n    public bool TryGetViewModel<TViewModel>(out ViewModelBase? vm) where TViewModel : ViewModelBase\n    {\n        if (_dic.TryGetValue(typeof(TViewModel), out var v))\n        {\n            vm = v;\n            return true;\n        }\n\n        vm = default;\n        return false;\n    }\n\n    #endregion\n\n    // 属性与字段\n\n    // 从类型到视图实例的字典\n    private readonly Dictionary<Type, ViewModelBase?> _dic;\n\n    // 宿主屏幕\n    private IScreen? _hostScreen;\n\n    public IScreen HostScreen\n    {\n        get => _hostScreen ?? throw new InvalidOperationException(\"未设置HostScreen\");\n        set => _hostScreen = value;\n    }\n\n    // 内置注册的视图模型\n\n    public DesktopViewModel DesktopViewModel => this.GetInstance<DesktopViewModel>();\n\n    public ResourceViewModel ResourceViewModel => this.GetInstance<ResourceViewModel>();\n\n    public WorkspaceViewModel WorkspaceViewModel => this.GetInstance<WorkspaceViewModel>();\n\n    public ToolboxViewModel ToolboxViewModel => this.GetInstance<ToolboxViewModel>();\n\n    public TerminalViewModel TerminalViewModel => this.GetInstance<TerminalViewModel>();\n\n    public AiViewModel AiViewModel => this.GetInstance<AiViewModel>();\n\n}\n```\n\n这不写还好，一写就开始出Bug了。\n\n我在BackCode和View中都注册了这个ViewModelLocator：\n\nApp.axaml.cs\n\n```csharp\n// 注册ViewModelLocator\nViewModelLocator.Instance.Init(state);\n```\n\nApp.axaml\n\n```xml\n<Application.Resources>\n\t<ResourceDictionary>\n\t\t<vm:ViewModelLocator x:Key=\"VmLocator\"/>\n\t</ResourceDictionary>\n</Application.Resources>\n```\n\n然后当我用Source绑定的时候，直接报错了...\n\n```xml\nCommand=\"{Binding Source={StaticResource VmLocator},Path=DesktopViewModel.OpenDesktopCommand}\"\n```\n\n> C:\\Users\\Hanser no maoguai\\source\\repos\\SharpDesktop\\SharpDesktop\\Views/DesktopView.axaml(43,19,43,19): Avalonia error AVLN2000: Unable to resolve property or method of name 'DesktopViewModel' on type 'System.Object'. 第 43 行，位置 19。\n\n不管我怎么改都编译不了，传入的值总是错误的，遂求助群里大佬，大佬让关掉编译绑定，虽然编译通过了，但是加载这个View仍然会报错，提示无法从空值解析到ViewModel。\n\n原因其实很简单。。。因为Avalonia的App中，BackCode和View各自注册了一个ViewModelLocator。。。我在断点调试时候发现，加载View的时候，ViewModelLocator调用了两次 `GetInstance<ViewModel>()`，第一次的TryGet有结果是True，第二次却是False，监视VM发现。。。这俩根本就不是一个单例。。。\n\n至于为啥能创建两个单例，我也没深究，可能是我没加线程锁的原因。\n\n最后我还是用RelativeResource解决的绑定问题：\n\n```xml\nCommand=\"{Binding RelativeSource={RelativeSource AncestorType=UserControl},Path=DataContext.OpenDesktopCommand}\"\n```\n","tags":[".NET"]},{"title":"通过EF在Avalonia中操作Sqlite","url":"/2024/10/31/通过EF在Avalonia中操作Sqlite/","content":"首选我们建个MVVM模板的项目，在项目中引入包 `Microsoft.EntityFrameworkCore.Sqlite`\n\n1、创建实体\n\n```c#\npublic class TodoEntity\n{\n    public Guid Id { get; set; }\n\n    public string Thing { get; set; }\n\n    public DateTime CreateTime { get; set; }\n}\n```\n\n2、创建上下文\n\n```cs\nublic class DatabaseContext : DbContext\n{\n    public DatabaseContext(DbContextOptions<DatabaseContext> options)\n        : base(options)\n    {\n    }\n  \n    public DbSet<TodoEntity> TodoEntities { get; set; }\n\n    protected override void OnModelCreating(ModelBuilder model)\n    {\n        model.Entity<TodoEntity>(m =>\n        {\n            m.ToTable(\"todo\");\n            m.Property(c => c.Id);\n            m.Property(c => c.Thing).IsRequired();\n            m.HasKey(c => c.Id);\n        });\n    }\n}\n```\n\n3、创建Factory\n\n```csharp\npublic class DatabaseContextFactory\n{\n    public DatabaseContext CreateDbContext(string[] args)\n    {\n\n        var m = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"todo.db\");\n        var options = new DbContextOptionsBuilder<DatabaseContext>();\n        options.UseSqlite($\"Data Source={m};\");\n        return new DatabaseContext(options.Options);\n    }\n\n    public DatabaseContext CreateDbContext() => CreateDbContext(new string[0]);\n}\n\n```\n\n4、启动时创建一下数据库\n\n```csharp\n public override void OnFrameworkInitializationCompleted()\n    {\n        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)\n        {\n            desktop.MainWindow = new MainWindow();\n\n            desktop.Startup += OnDesktopOnStartup;\n        }\n\n        base.OnFrameworkInitializationCompleted();\n    }\n\n    private void OnDesktopOnStartup(object sender, ControlledApplicationLifetimeStartupEventArgs args)\n    {\n        using var db = new DatabaseContextFactory().CreateDbContext();\n        db.Database.EnsureCreated();\n    }\n```\n\n5、修改MainWindowViewModel\n\n```csharp\npublic class MainWindowViewModel : ViewModelBase\n{\n    private ObservableCollection<TodoEntity> _todoEntities = new();\n\n    public ObservableCollection<TodoEntity> TodoEntities\n    {\n        get => _todoEntities;\n        set => this.RaiseAndSetIfChanged(ref _todoEntities, value);\n    }\n\n    public void Add(string thing)\n    {\n        using var db = new DatabaseContextFactory().CreateDbContext();\n        db.TodoEntities.Add(new TodoEntity()\n        {\n            Id = new Guid(),\n            Thing = thing,\n            CreateTime = DateTime.Now\n        });\n        db.SaveChanges();\n    }\n\n    public void Refresh()\n    {\n        using var db = new DatabaseContextFactory().CreateDbContext();\n        var m = db.TodoEntities.ToList();\n        TodoEntities.Clear();\n        TodoEntities.AddRange(m);\n    }\n  \n    public void Clear()\n    {\n        TodoEntities.Clear();\n        using var db = new DatabaseContextFactory().CreateDbContext();\n        var m = db.TodoEntities.ToList();\n        db.TodoEntities.RemoveRange(m);\n        db.SaveChanges();\n    }\n}\n```\n\n6、修改MainWindow\n\n```xaml\n<Window xmlns=\"https://github.com/avaloniaui\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        xmlns:vm=\"using:SqliteEFDemo.ViewModels\"\n        xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n        xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n        mc:Ignorable=\"d\" d:DesignWidth=\"500\" d:DesignHeight=\"450\"\n        Width=\"500\"\n        x:Class=\"SqliteEFDemo.Views.MainWindow\"\n        x:DataType=\"vm:MainWindowViewModel\"\n        Icon=\"/Assets/avalonia-logo.ico\"\n        Title=\"SqliteEFDemo\">\n\n    <Design.DataContext>\n        <!-- This only sets the DataContext for the previewer in an IDE,\n             to set the actual DataContext for runtime, set the DataContext property in code (look at App.axaml.cs) -->\n        <vm:MainWindowViewModel/>\n    </Design.DataContext>\n\n    <Grid RowDefinitions=\"Auto,*\">\n        <StackPanel Orientation=\"Horizontal\" Spacing=\"20\" Margin=\"10 0\">\n            <TextBox Name=\"Thing\" Width=\"200\" />\n            <Button Content=\"Add\" x:Name=\"Add\" Click=\"Add_OnClick\"/>\n            <Button Content=\"Refresh\" x:Name=\"Refresh\" Click=\"Refresh_OnClick\"/>\n            <Button Content=\"Clear\" x:Name=\"Clear\" Click=\"Clear_OnClick\"/>\n        </StackPanel>\n      \n        <StackPanel Orientation=\"Vertical\" Grid.Row=\"1\">\n            <ItemsControl Items=\"{Binding TodoEntities}\">\n                <ItemsControl.ItemTemplate>\n                    <DataTemplate>\n                        <TextBlock Text=\"{Binding Thing}\" Margin=\"20 10\"/>\n                    </DataTemplate>\n                </ItemsControl.ItemTemplate>\n            </ItemsControl>\n        </StackPanel>\n    </Grid>\n  \n</Window>\n\n```\n\n7、修改MainWindow.axaml.cs\n\n```csharp\npublic partial class MainWindow : Window\n{\n    private MainWindowViewModel vm;\n    public MainWindow()\n    {\n        InitializeComponent();\n        vm = new MainWindowViewModel();\n        this.DataContext = vm;\n        vm.Refresh();\n    }\n\n    private void Add_OnClick(object? sender, RoutedEventArgs e)\n    {\n        var thingTb = this.FindControl<TextBox>(\"Thing\");\n\n        var s = thingTb?.Text?.Trim();\n        if (!string.IsNullOrEmpty(s))\n        {\n            vm.Add(s);\n            vm.Refresh();\n        }\n    }\n\n    private void Refresh_OnClick(object? sender, RoutedEventArgs e)\n    {\n        vm.Refresh();\n    }\n\n    private void Clear_OnClick(object? sender, RoutedEventArgs e)\n    {\n        vm.Clear();\n    }\n}\n```\n\n![](https://img2023.cnblogs.com/blog/719904/202305/719904-20230529163532763-1335029925.png)\n\n如果要使用加密的sqlite, 要引入包 `*SQLitePCLRaw.bundle_e_sqlcipher*` , 不然会出现\n\n`You specified a password in the connection string, but the native SQLite library 'e_sqlite3' doesn't support encryption.` 的报错信息\n\n同时把Factory改为下面这样\n\n```csharp\npublic class DatabaseContextFactory\n{\n    public DatabaseContext CreateDbContext(string[] args)\n    {\n        var m = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"todo.db\");\n        var options = new DbContextOptionsBuilder<DatabaseContext>();\n\n        //要加密 需要引入包 SQLitePCLRaw.bundle_e_sqlcipher\n        var connStr = new SqliteConnectionStringBuilder()\n        {\n            DataSource = m,\n            Mode = SqliteOpenMode.ReadWriteCreate,\n            Password = \"admin\"\n        }.ToString();\n\n        options.UseSqlite(connStr);\n        return new DatabaseContext(options.Options);\n    }\n\n    public DatabaseContext CreateDbContext() => CreateDbContext(new string[0]);\n}\n```\n","tags":[".NET"]},{"title":"C#调用系统底层win32API","url":"/2024/10/30/C-调用系统底层win32API/","content":"最近学习 C# 学到了本机互操作性，之前一直有需求需要调用 [Win32 API](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/apiindex/windows-api-list)，查阅了许多资料踩了不少坑（如类型映射、封送结构等），现在整理出一套调用 Win32 API 的方法，因此记录一下顺便分享给大家参考。\n\n## **概念**\n\n*.NET 采用 **P/Invoke** 技术来从托管代码访问访问非托管库中的结构、回调和函数的一种技术，大多数 P/Invoke API 包含在以下两个命名空间中：`System` 和 `System.Runtime.InteropServices`。 使用这两个命名空间可提供用于描述如何与本机组件通信的工具（引用来源：[平台调用 (P/Invoke) | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/pinvoke)）。*\n\n可以简单理解为 .NET 可以调用使用 C/C++ 开发的库中的函数，通常用于调用 [Win32 API](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/apiindex/windows-api-list)。\n\n## **最小示例**\n\n以下是最小示例，下面示例中调用了 Win32 API 中的 [MessageBox](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-messagebox) 函数，*该函数显示一个模式对话框，其中包含一个系统图标、一组按钮和一条简短的应用程序特定消息，例如状态或错误信息。 消息框返回一个整数值，指示用户单击的按钮（引用来源：[MessageBox 函数 (winuser.h) - Win32 apps | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-messagebox)）。*\n\n示例来源：[平台调用 (P/Invoke) | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/pinvoke)。\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\npublic class Program\n{\n    // Import user32.dll (containing the function we need) and define\n    // the method corresponding to the native function.\n    [DllImport(\"user32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n    private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);\n\n    public static void Main(string[] args)\n    {\n        // Invoke the function as a regular managed method.\n        MessageBox(IntPtr.Zero, \"Command-line message box\", \"Attention!\", 0);\n    }\n}\n```\n\n上述示例非常简单，但确实演示了从托管代码调用非托管函数所需执行的操作。 让我们逐步分析该示例：\n\n* 第 2 行显示 `System.Runtime.InteropServices` 命名空间（用于保存全部所需项）的 using 语句。\n* 第 8 行引入 `DllImport` 属性。 此属性将告诉运行时应该加载非托管 DLL。 传入的字符串是目标函数所在的 DLL。 此外，它还指定哪些[字符集](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/charset)用于封送字符串。 最后，它指定此函数调用 [SetLastError](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror)，且运行时应捕获相应错误代码，以便用户能够通过 [Marshal.GetLastWin32Error()](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal.getlastwin32error%23system-runtime-interopservices-marshal-getlastwin32error) 检索它。\n* 第 9 行显示了 P/Invoke 的关键作用。 它定义了一个托管方法，该方法的签名与非托管方法 **完全相同** 。 可以看到，声明中包含一个新关键字 `extern`，告诉运行时这是一个外部方法。调用该方法时，运行时应在 `DllImport` 特性中指定的 DLL 内查找该方法。\n\n*（引用来源：[平台调用 (P/Invoke) | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/pinvoke)）*\n\n示例代码运行后结果如下图：\n\n![](https://pica.zhimg.com/v2-fddb2e45c7259ef992f2ae85bc1a5b20_b.jpg)\n\n上面的解释中仍然存在一些疑惑，比如 *“该方法的签名与非托管方法完全相同”* ，但 C# 中的类型和 C/C++ 中的类型并不完全一样，那么应当是存在一套类型的转换方法，官网示例中并未提到该方法，下面我会为大家说明类型映射方法。\n\n## **类型封送**\n\nC# 和 C/C++ 的类型并不完全一致，因此需要一套类型映射表来进行转换后再发送给 C/C++ 程序，这种技术叫做 **类型封送（Type Marshalling）** ， *封送是当类型需要在托管代码和本机代码之间切换时转换类型的过程。（引用来源：[类型封送 - .NET | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/type-marshalling)）* 。\n\n### **基本类型映射**\n\n对于 C/C++ 基本类型，官方给出了对应的 C# 类型映射表：\n\n| C# 关键字 | .NET 类型                                                   | 本机类型                                                                 |\n| --------- | ----------------------------------------------------------- | ------------------------------------------------------------------------ |\n| byte      | System.Byte                                                 | uint8_t                                                                  |\n| sbyte     | System.SByte                                                | int8_t                                                                   |\n| short     | System.Int16                                                | int16_t                                                                  |\n| ushort    | System.UInt16                                               | uint16_t                                                                 |\n| int       | System.Int32                                                | int32_t                                                                  |\n| uint      | System.UInt32                                               | uint32_t                                                                 |\n| long      | System.Int64                                                | int64_t                                                                  |\n| ulong     | System.UInt64                                               | uint64_t                                                                 |\n| char      | System.Char                                                 | char 或 char16_t 依赖于 P/Invoke 或结构的 CharSet。 请参阅字符集文档。   |\n|           | System.Char                                                 | char* 或 char16_t* 依赖于 P/Invoke 或结构的 CharSet。 请参阅字符集文档。 |\n| nint      | System.IntPtr                                               | intptr_t                                                                 |\n| nuint     | System.UIntPtr                                              | uintptr_t                                                                |\n|           | .NET 指针类型（例如，void*）                                | void*                                                                    |\n|           | 从 System.Runtime.InteropServices.SafeHandle 派生的类型     | void*                                                                    |\n|           | 从 System.Runtime.InteropServices.CriticalHandle 派生的类型 | void*                                                                    |\n| bool      | System.Boolean                                              | Win32 BOOL 类型                                                          |\n| decimal   | System.Decimal                                              | COM DECIMAL 结构                                                         |\n|           | .NET 委托                                                   | 本机函数指针                                                             |\n|           | System.DateTime                                             | Win32 DATE 类型                                                          |\n|           | System.Guid                                                 | Win32 GUID 类型                                                          |\n\n*（引用来源：[类型封送 - .NET | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/type-marshalling%23default-rules-for-marshalling-common-types)）*\n\n但 Win32 API 大部分类型并没有直接使用 C/C++ 基本类型，而是使用了 Windows 数据类型，对此官方也给出了封送常见 Windows 数据类型对应的 C# 类型表：\n\n| Windows        | C#     |\n| -------------- | ------ |\n| BOOL           | int    |\n| BOOLEAN        | byte   |\n| BYTE           | byte   |\n| UCHAR          | byte   |\n| UINT8          | byte   |\n| CCHAR          | byte   |\n| CHAR           | sbyte  |\n| CHAR           | sbyte  |\n| INT8           | sbyte  |\n| CSHORT         | short  |\n| INT16          | short  |\n| SHORT          | short  |\n| ATOM           | ushort |\n| UINT16         | ushort |\n| USHORT         | ushort |\n| WORD           | ushort |\n| INT            | int    |\n| INT32          | int    |\n| LONG           | int    |\n| LONG32         | int    |\n| CLONG          | uint   |\n| DWORD          | uint   |\n| DWORD32        | uint   |\n| UINT           | uint   |\n| UINT32         | uint   |\n| ULONG          | uint   |\n| ULONG32        | uint   |\n| INT64          | long   |\n| LARGE_INTEGER  | long   |\n| LONG64         | long   |\n| LONGLONG       | long   |\n| QWORD          | long   |\n| DWORD64        | ulong  |\n| UINT64         | ulong  |\n| ULONG64        | ulong  |\n| ULONGLONG      | ulong  |\n| ULARGE_INTEGER | ulong  |\n| HRESULT        | int    |\n| NTSTATUS       | int    |\n\n*（表格来源：[本机互操作性最佳做法 - .NET | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/best-practices%23common-windows-data-types)，内容略作调整修改）*\n\n此外，Win32 API 中还有一些常见的指针类型，转换表如下：\n\n| 已签名的指针类型（C# 中使用 System.IntPtr 或 nint） | 未签名的指针类型（C# 中使用 System.UIntPtr 或 nuint） |\n| --------------------------------------------------- | ----------------------------------------------------- |\n| HANDLE                                              | WPARAM                                                |\n| HWND                                                | UINT_PTR                                              |\n| HINSTANCE                                           | ULONG_PTR                                             |\n| LPARAM                                              | SIZE_T                                                |\n| LRESULT                                             |                                                       |\n| LONG_PTR                                            |                                                       |\n| INT_PTR                                             |                                                       |\n\n*（表格来源：[本机互操作性最佳做法 - .NET | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/best-practices%23common-windows-data-types)，内容略作调整修改）*\n\n### **基本类型映射示例**\n\n以上面[最小示例](https://zhuanlan.zhihu.com/p/653484348/edit#%E6%9C%80%E5%B0%8F%E7%A4%BA%E4%BE%8B)提到的 [MessageBox](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-messagebox) 函数为例，它在 C++ 的签名如下：\n\n```cpp\nint MessageBox(\n  [in, optional] HWND    hWnd,\n  [in, optional] LPCTSTR lpText,\n  [in, optional] LPCTSTR lpCaption,\n  [in]           UINT    uType\n);\n```\n\n经过查表得知，入参中的 `HWND` 对应 `System.IntPtr` 或 `nint`，`LPCTSTR` 貌似没有在表中找到，这里看上去应该用 `string`（对于找不到映射的类型，后面会介绍更方便的类型转换方法），`UINT` 对应 `int`，返回类型的 `int` 对应 `int`。\n\n此外从 [MessageBox 函数 (winuser.h) - Win32 apps | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-messagebox%23requirements) 要求部分可以得知，该函数存在于 `User32.dll` 文件中，因此使用 `DllImport` 特性第一个参数应当为 `user32.dll`（大小写不敏感）。\n\n因此该签名转换为 C# 签名如下：\n\n```csharp\n[DllImport(\"user32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\nprivate static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);\n```\n\n### **结构类型封送**\n\n有的时候，我们需要封送结构（struct）类型，此时会用到 [StructLayout](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.structlayoutattribute%3Fview%3Dnet-7.0) 特性，使用方法如下：\n\n```csharp\n[DllImport(\"kernel32.dll\")]\nstatic extern void GetSystemTime(SystemTime systemTime);\n\n[StructLayout(LayoutKind.Sequential)]\nclass SystemTime {\n    public ushort Year;\n    public ushort Month;\n    public ushort DayOfWeek;\n    public ushort Day;\n    public ushort Hour;\n    public ushort Minute;\n    public ushort Second;\n    public ushort Millisecond;\n}\n\npublic static void Main(string[] args) {\n    SystemTime st = new SystemTime();\n    GetSystemTime(st);\n    Console.WriteLine(st.Year);\n}\n```\n\n*（代码来源：[类型封送 - .NET | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/standard/native-interop/type-marshalling%23marshalling-classes-and-structs)）*\n\n当然，官方示例代码中使用的 `class` 也是可以的，具体使用 `class` 还是 `struct` 可以根据实际需求决定。\n\n### **指针类型处理**\n\n有的 Win32 API 会用到指针类型（通常以 `LP` 开头，具体以官方文档为准），C/C++ 中指针可以用于入参和出参，这两个需要在 C# 中特别处理。\n\n### **入参指针**\n\n入参指针对应 C# 中的 [in 关键字](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/in-parameter-modifier) 或 [ref 关键字](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref)，这两者均能正常工作，具体区别请查看官方文档，这里不作具体解释。\n\n以 [TranslateMessage](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-translatemessage) API 为例，它在 C/C++ 中的签名如下：\n\n```cpp\nBOOL TranslateMessage(\n  [in] const MSG *lpMsg\n);\n```\n\n这里的 `*lpMsg` 前有个指针符号 `*`，加上最前面的 `[in]`，说明它是入参指针，因此转换为 C# 签名如下：\n\n```csharp\n[DllImport(\"user32.dll\", SetLastError = true)]\nprivate static extern int TranslateMessage(in MSG lpMsg);\n```\n\n可以看到，`const MSG *lpMsg` 被转换为了 C# 中的 `in MSG lpMsg`。\n\n### **出参指针**\n\n出参（返回值）指针对应 C# 中的 [out](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier) 关键字，以 [GetMessage](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getmessage) API 为例，它在 C/C++ 中的签名如下：\n\n```cpp\nBOOL GetMessage(\n  [out]          LPMSG lpMsg,\n  [in, optional] HWND  hWnd,\n  [in]           UINT  wMsgFilterMin,\n  [in]           UINT  wMsgFilterMax\n);\n```\n\n这里的 `lpMsg` 入参前面有个 `[out]` 字样，说明它是出参指针，转换为 C# 签名如下：\n\n```csharp\n[DllImport(\"user32.dll\", SetLastError = true)]\nprivate static extern int GetMessage(out MSG lpMsg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax);\n```\n\n可以看到，`LPMSG lpMsg` 参数在 C# 中被转换为了 `out MSG lpMsg`。\n\n### **更简便方法**\n\n如果项目中要用到大量 Win32 API，每个签名都要自己写一遍确实是很麻烦，而且有的 C++ Windows 类型官方并没有给出 C# 中对应的类型映射（比如 `LPCTSTR`），这里有一个更简便的方法来编写签名：[pinvoke.net: the interop wiki!](https://link.zhihu.com/?target=http%3A//pinvoke.net/index.aspx)。\n\n该网站记录了大量的 Win32 API 在 C# 或 VB 中的签名，因此你可以直接复制过来使用，还是以 `MessageBox` 函数为例，我们在该网站左上角搜索该函数，然后在搜索结果中找到 `MessageBox` 函数并打开结果页：[pinvoke.net: MessageBox (user32)](https://link.zhihu.com/?target=http%3A//pinvoke.net/default.aspx/user32/MessageBox.html)：\n\n![](https://pic4.zhimg.com/v2-fd11acad2fc58bb46010e4d1bcd8aab9_b.jpg)\n\n![](https://picx.zhimg.com/v2-87fa5a728e6cb0305550ddbd11d090dd_b.jpg)\n\n![](https://pic2.zhimg.com/v2-8e65bd9aaac3a6e8377e5f66797bebfd_b.jpg)\n\n可以看到，在“C# Signature”中，已经帮我们写好了该 Win32 API 在 C# 中对应的签名，我们直接复制使用就可以了。\n\n## **回调（委托）**\n\n有的 API 需要传入回调函数，这里应当使用 [delegate 关键字](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/csharp/delegate-class) 来创建委托函数，如 [SetWindowsHookEx](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowshookexa) 函数的参数 2 使用到了回调函数，类型为 [HookProc](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/api/winuser/nc-winuser-hookproc)，该函数 C++ 签名如下：\n\n```cpp\nLRESULT Hookproc(\n       int code,\n  [in] WPARAM wParam,\n  [in] LPARAM lParam\n)\n```\n\n转换为 C# 签名如下：\n\n```csharp\ndelegate IntPtr HookProc(int code, IntPtr wParam, IntPtr lParam);\n```\n\n使用方法如下：\n\n```csharp\n// 签名定义\n[DllImport(\"User32.dll\", SetLastError = true)]\nstatic extern nint SetWindowsHookEx(int hookType, HookProc lpfn, nint hMod, int dwThreadId);\ndelegate IntPtr HookProc(int code, IntPtr wParam, IntPtr lParam);\n\n// 使用\nHookProc callback = new((int code, nint wParam, nint lParam) =>\n{\n    // 具体代码实现省略\n    return CallNextHookEx(0, code, wParam, lParam);\n});\nSetWindowsHookEx(14, callback, 0, 0);\n```\n\n当然，这个签名转换也能在 [pinvoke.net: HookProc (Delegates)](https://link.zhihu.com/?target=http%3A//pinvoke.net/default.aspx/Delegates/HookProc.html) 中找到。\n\n## **非托管内存管理**\n\n有的 API 需要操作内存，.NET 提供了 API 来操作非托管内存：[Marshal 类 (System.Runtime.InteropServices) | Microsoft Learn](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.marshal%3Fview%3Dnet-7.0)。以[复制纯文本到剪贴板](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/dataxchg/using-the-clipboard%23copying-information-to-the-clipboard)为例，示例代码请查看：[复制文本到剪贴板](https://zhuanlan.zhihu.com/p/653484348/edit#%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E5%88%B0%E5%89%AA%E8%B4%B4%E6%9D%BF)。\n\n## **示例**\n\n为方便大家理解，这里提供一些个人写的一些示例。\n\n### **监控并打印光标位置**\n\n```csharp\nusing System.Runtime.InteropServices;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\npublic class Program\n{\n    [StructLayout(LayoutKind.Sequential)]\n    public record struct POINT(int X, int Y);\n    [StructLayout(LayoutKind.Sequential)]\n    public struct MSG\n    {\n        public nint hwnd;\n        public int message;\n        public int wParam;\n        public int lParam;\n        public int time;\n        public POINT pt;\n        public int lPrivate;\n    }\n\n    [DllImport(\"user32.dll\", SetLastError = true)]\n    private static extern int GetMessage(out MSG lpMsg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax);\n    [DllImport(\"user32.dll\", SetLastError = true)]\n    private static extern int TranslateMessage(in MSG lpMsg);\n    [DllImport(\"user32.dll\", SetLastError = true)]\n    private static extern int DispatchMessage(in MSG lpMsg);\n\n    delegate nint HookProc(int code, nint wParam, nint lParam);\n\n    [DllImport(\"User32.dll\", SetLastError = true)]\n    static extern nint SetWindowsHookEx(int hookType, HookProc lpfn, nint hMod, int dwThreadId);\n\n    [DllImport(\"user32.dll\", SetLastError = true)]\n    static extern bool UnhookWindowsHookEx(nint hhk);\n\n    [DllImport(\"user32.dll\")]\n    static extern nint CallNextHookEx(nint hhk, int nCode, nint wParam, nint lParam);\n    [StructLayout(LayoutKind.Sequential)]\n    public struct MSLLHOOKSTRUCT\n    {\n        [JsonInclude]\n        public POINT pt;\n        [JsonInclude]\n        public int mouseData;\n        [JsonInclude]\n        public int flags;\n        [JsonInclude]\n        public int time;\n        public nuint dwExtraInfo;\n    }\n\n    public static void Main(string[] args)\n    {\n        HookProc callback = new((int code, nint wParam, nint lParam) =>\n        {\n            MSLLHOOKSTRUCT data = Marshal.PtrToStructure<MSLLHOOKSTRUCT>(lParam);\n            Console.WriteLine(JsonSerializer.Serialize(data));\n            return CallNextHookEx(0, code, wParam, lParam);\n        });\n        SetWindowsHookEx(14, callback, 0, 0);\n\n        MSG msg;\n        while (GetMessage(out msg, 0, 0, 0) > 0)\n        {\n            TranslateMessage(in msg);\n            DispatchMessage(in msg);\n        }\n    }\n}\n```\n\n### **复制文本到剪贴板**\n\n```csharp\nusing System.Runtime.InteropServices;\nusing System.Text;\n\npublic class Program\n{\n    [DllImport(\"user32.dll\", SetLastError = true)]\n    static extern bool OpenClipboard(IntPtr hWndNewOwner);\n    [DllImport(\"user32.dll\")]\n    static extern bool EmptyClipboard();\n    [DllImport(\"user32.dll\", SetLastError = true)]\n    static extern int SetClipboardData(int uFormat, IntPtr hMem);\n    [DllImport(\"kernel32.dll\")]\n    static extern IntPtr GlobalLock(IntPtr hMem);\n    [DllImport(\"kernel32.dll\")]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    static extern bool GlobalUnlock(IntPtr hMem);\n\n    public static void Main()\n    {\n        // 复制当前时间到剪贴板，\"\\0\"指示字符串结束\n        string text = $\"现在是北京时间 {DateTime.Now}\\0\";\n\n        // 打开剪贴板\n        if (!OpenClipboard(IntPtr.Zero))\n        {\n            Console.WriteLine(\"打开剪贴板失败。\");\n            return;\n        }\n\n        // 清空剪贴板\n        EmptyClipboard();\n\n        // 文本编码为 Unicode 字节数组\n        var encoder = new UnicodeEncoding();\n        byte[] buffer = encoder.GetBytes(text);\n\n        // 分配内存\n        var hglbCopy = Marshal.AllocHGlobal(buffer.Length);\n        // 锁定内存\n        var lptstrCopy = GlobalLock(hglbCopy);\n        // 写入内存\n        int offset = 0;\n        foreach (var b in buffer)\n        {\n            Marshal.WriteByte(lptstrCopy, offset, b);\n            offset++;\n        }\n        // 解锁内存\n        GlobalUnlock(hglbCopy);\n        // 设置剪贴板数据，13 指示格式为 Unicode 文本，枚举参考：https://learn.microsoft.com/zh-cn/windows/win32/dataxchg/standard-clipboard-formats#constants\n        SetClipboardData(13, hglbCopy);\n        // 释放内存\n        Marshal.FreeHGlobal(hglbCopy);\n    }\n}\n```\n","tags":[".NET"]},{"title":"10.24随笔","url":"/2024/10/24/10-24随笔/","content":"现在想来，还得感谢9月份的时候，电脑正好坏掉送去维修，终于有时间自己停下来好好想想了，若不是这个契机，想必今天也不会有这么深的感悟。当一个人的理想和现实割裂的时候，裂口里留下的只有虚无与迷茫。从创业到择业，想的越多，迷茫就越来越涌上心头。\n\n我原轻薄地认为自己与自己的内心和解便是天下无双，可当那个本我与真我一起停在岔路口上的时候，才发现向未来走去的路，孤独、漫长、模糊。兴许“迷茫”正是前半辈子的主旋律，但这旋律奏到高潮的时候，我的行为却也被它左右了：这些个白昼与黑夜，学习之外的生活里塞满了求助与请教，乃至最严重的某一天，我甚至觉得人的这一辈子就是没有意义的。我不知道我在哪，我不知道我应该去哪里，我也不知道我为什么要思考自己应该去哪里。\n\n所以那天我早早地睡了，六点起来赶了个大早。\n\n晨光没有那么吝啬地躲到我起床之后的几个小时里，早早地晃醒了世界，也悄悄地不去惊动没来得及逃走的星辰。\n\n我突然觉得早晨的风真是可爱，骑着车去买早餐的路上只有我一个人，就好像在土星的光环上滑行。\n\n一条没有尽头的路上，只有一个自命清高的人欣赏着孤独和星河，他像朝霞一样温暖，他和星光一样浪漫。\n\n于是我就突然地就清醒过来了，尽管我并没有想明白什么东西。\n\n我仍然不知道自己在哪里，应该去到哪里，这一切有什么意义。\n\n\n我只知道我的前路仍然一片未知，\n\n真有意思。\n\n\n2024.10.24秋夜，于武汉\n","tags":["成长"]},{"title":"Vue重学计划（六）","url":"/2024/10/16/Vue重学计划（六）/","content":"上一节聊完了SCSS和BEM架构，这一节来说说Vue中的组件部分，组件内容比较多，可能会用好几期博客来慢慢复习了。\n\n这一期简单讲讲组件基础知识吧。\n\n# 生命周期\n\n前端工程尽管是面向对象的，但是由于视觉上的呈现，需要经过一个渲染的加载过程，许多前端的框架和引擎都会天然提供生命周期的钩子，方便在不同的加载阶段执行不同的操作\n\n例如，在Unity开发中，我们的代码是这样的：\n\n```csharp\nusing System;\nusing UnityEngine;\n\npublic void GameBoot : Monobehaviour\n{\n\t// 组件初始化\n\tvoid Awake(){}\n\n\t// 组件初始化完成\n\tvoid Start(){}\n\n\t// 组件启用\n\tvoid OnEnable(){}\n\n\t// 组件禁用\n\tvoid OnDisable(){}\n\n\t// 组件每一帧更新\n\tvoid Update(){}\n\n\t// 组件销毁\n\tvoid OnDestroy(){}\n}\n```\n\n类似地，Vue框架也提供了生命周期钩子：\n\n```html\n<template>\n    <h1>\n        This is a component demo\n    </h1>\n    <div ref=\"div\">{{ str }}</div>\n    <button @click=\"change\">修改</button>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onActivated, onDeactivated, onRenderTracked, onRenderTriggered, onErrorCaptured, onServerPrefetch } from 'vue'\n// beforeCreate，created 在setup语法糖模式中没有这两个生命周期\nconsole.log('setup')\nconst str = ref('hello')\nconst div = ref<HTMLDivElement>()\n\nconst change = () => {\n    str.value = 'world'\n}\n\n//创建\nonBeforeMount(() => {\n    console.log('beforeMount', div.value)\n})\n\nonMounted(() => {\n    console.log('mounted', div.value)\n})\n//更新\n// 为什么这里面加了?.innerText前后，控制台输出的值不一样？？？\nonBeforeUpdate(() => {\n    console.log('beforeUpdate', div.value?.innerText)\n})\nonUpdated(() => {\n    console.log('updated', div.value?.innerText)\n})\n//销毁\nonBeforeUnmount(() => {\n    console.log('beforeUnmount')\n})\n\nonUnmounted(() => {\n    console.log('unmounted')\n})\n//调试\nonRenderTracked((e) => {\n    console.log('renderTracked')\n    console.log(e)\n})\nonRenderTriggered((e) => {\n    console.log('renderTriggered')\n    console.log(e)\n})\n</script>\n\n<style lang=\"css\" scoped></style>\n```\n\n值得一提的是：\n\n在我们使用[Vue3](https://so.csdn.net/so/search?q=Vue3&spm=1001.2101.3001.7020) 组合式API 是没有 `beforeCreate 和 created`这两个生命周期的\n\n# 组件传参\n\n组件传参大概有两个方向\n\n### 父组件向子组件传参\n\n子组件通过defineProperties来定义自己的属性参数，父组件通过v-bind指令来给每个属性传入一个参数，例如：\n\n子组件.ts\n\n```typescript\n<template>\n    <div class=\"menu\">\n        菜单区域 {{ title }}\n        <div>{{ data }}</div>\n    </div>\n</template>\n \n<script setup lang=\"ts\">\ndefineProps<{\n    title:string,\n    data:number[]\n}>()\n</script>\n```\n\n父组件.ts\n\n```typescript\n<template>\n    <div class=\"layout\">\n        <Menu v-bind:data=\"data\"  title=\"我是标题\"></Menu>\n        <div class=\"layout-right\">\n            <Header></Header>\n            <Content></Content>\n        </div>\n    </div>\n</template>\n \n<script setup lang=\"ts\">\nimport Menu from './Menu/index.vue'\nimport Header from './Header/index.vue'\nimport Content from './Content/index.vue'\nimport { reactive } from 'vue';\n \nconst data = reactive<number[]>([1, 2, 3])\n</script>\n```\n\n传递字符串类型，不需要v-bind，传递非字符串类型需要加v-bind，当然也可以用简写形式.\n\n如果想设置默认值，可以使用withDefault函数\n\n```typescript\ntype Props = {\n    title?: string,\n    data?: number[]\n}\nwithDefaults(defineProps<Props>(), {\n    title: \"张三\",\n    data: () => [1, 2, 3]\n})\n```\n\n### 子组件向父组件传参\n\n这种传参有两个形式，一种是父组件通过方法来从子组件获取参数，另一种是子组件主动向父组件暴露参数，这两种方法各有各的应用场景，咱们分别来看看例子：\n\n1. 子组件通过emit暴露事件\n\n```type\n<template>\n    <div class=\"menu\">\n        <button @click=\"clickTap\">派发给父组件</button>\n    </div>\n</template>\n \n<script setup lang=\"ts\">\nimport { reactive } from 'vue'\nconst list = reactive<number[]>([4, 5, 6])\n \nconst emit = defineEmits(['on-click'])\n \n//如果用了ts可以这样两种方式\n// const emit = defineEmits<{\n//     (e: \"on-click\", name: string): void\n// }>()\nconst clickTap = () => {\n    emit('on-click', list)\n}\n \n</script>\n```\n\n\n我们在子组件绑定了一个click 事件 然后通过defineEmits 注册了一个自定义事件\n\n点击click 触发 emit 去调用我们注册的事件 然后传递参数，父组件接受子组件的事件。\n\n```typescript\n<template>\n    <div class=\"layout\">\n        <Menu @on-click=\"getList\"></Menu>\n        <div class=\"layout-right\">\n            <Header></Header>\n            <Content></Content>\n        </div>\n    </div>\n</template>\n \n<script setup lang=\"ts\">\nimport Menu from './Menu/index.vue'\nimport Header from './Header/index.vue'\nimport Content from './Content/index.vue'\nimport { reactive } from 'vue';\n \nconst data = reactive<number[]>([1, 2, 3])\n \nconst getList = (list: number[]) => {\n    console.log(list,'父组件接受子组件');\n}\n</script>\n```\n\n我们从Menu 组件接受子组件派发的事件on-click 后面是我们自己定义的函数名称getList,会把参数返回过来\n\n2. 子组件暴露给父组件内部属性\n\n子组件暴露属性通过defineExpose\n\n我们从父组件获取子组件实例通过ref：\n\n```html\n <Menu ref=\"refMenu\"></Menu>\n//这样获取是有代码提示的\n<script setup lang=\"ts\">\nimport MenuCom from '../xxxxxxx.vue'\n//注意这儿的typeof里面放的是组件名字(MenuCom)不是ref的名字 ref的名字对应开头的变量名(refMenu)\nconst refMenu = ref<InstanceType<typeof MenuCom>>()\n</script>\n```\n\n这时候父组件想要读到子组件的属性可以通过 defineExpose暴露，子组件中这样写：\n\n```typescript\nconst list = reactive<number[]>([4, 5, 6])\n \ndefineExpose({\n    list\n})\n```\n","tags":["前端"],"categories":["Vue3重学计划"]},{"title":"Java新特性日志——Java 8","url":"/2024/10/16/Java新特性日志——Java 8/","content":"这几天忙着处理留学的一些事情，博客断更了几天，今天重新启动！\n\n感觉自己快要被多方势力撕裂了，每天都在被不同的建议和思想折磨。。。原本清晰的目标却一天天地模糊了。闲暇时间，读了读汤显祖的《牡丹亭》，文言文也啃不动，只觉得大脑去思考那些文字，比被乱七八糟的思想折磨要舒服。\n\n这几天忙，也没学什么新知识，干脆做个新特性日志，以后当个Log查查好了，还能有点意义。\n\n# Java长期支持版本（LTS）\n\n经常用Java的同学都知道，Java经过数十年的发展，版本的选择也成了一个难题。\n\n> Java 现在发布的版本很快，每年两个，但是真正会被大规模使用的是 3 年一个的 LTS 版本。\n\n* 每 3 年发布一个 LTS（Long-Term Support），长期维护版本。意味着只有 **Java 8 ，Java 11， Java 17，Java 21 才可能被大规模使用** 。\n* 每年发布两个正式版本，分别是 3 月份和 9 月份。\n\n而我们开发的时候，关注Java 8和Java 17这两个节点就可以了，因为Java 8引入很多非常实用的新特性，而Java 17对Spring框架提供了基本的支持，其他版本的话就视项目和个人喜好而定了。\n\n# Java 8为啥这么出名\n\n相信很多初学JavaSE的同学，使用的第一个版本就是Java 8，甚至很多面试的同学，在简历上写“熟悉Java 8特性”可以成为一个加分项。这就离不开Java 8 的一些新特性了。\n\n一个最主要原因还是商业收费的问题，不过另一个原因就是Java 8出众的新特性：\n\n### Lambda表达式\n\n在Java 8之前，我们的匿名内部类是这样的：\n\n```java\npublic static void main(String[] args) {\n    //新建一个线程\n    Thread thread = new Thread(new Runnable() {   \n\t//创建一个实现Runnable的匿名内部类\n        @Override\n        public void run() {   \n\t    //具体的实现逻辑\n            System.out.println(\"Hello World!\");\n        }\n    });\n    thread.start();\n}\n```\n\n使用Java 8的Lambda表达式，可以简写成这样的：\n\n```java\npublic static void main(String[] args) {\n    //新建一个线程\n    Thread thread = new Thread(() -> {\n        System.out.println(\"Hello World!\");  //Lambda方法实现\n    });\n    thread.start();\n}\n```\n\n> 它的底层其实并不只是简简单单的语法糖替换，而是通过 `invokedynamic`指令实现的，不难发现，匿名内部类会在编译时创建一个单独的class文件，但是lambda却不会，间接说明编译之后lambda并不是以匿名内部类的形式存在的：\n\n```java\nThread thread = new Thread(() -> {\n    throw new UnsupportedOperationException();   \n});\nthread.start();\n```\n\n> 可以看到，实际上是Main类中的 `lambda$main$0()`方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。比如Runnable接口需要一个方法体对它的 `run()`方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。\n\nLambda表达式的具体规范：\n\n* 格式：`([参数类型 参数名称,]...) ‐> { 代码语句，包括返回值 }`\n* 和匿名内部类不同，Lambda仅支持接口，不支持抽象类\n* 接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）\n\n### 方法引用与函数式接口\n\nLambda表达式的另一个用法是直接引用，可以认为是一种**方法****引用**，例如\n\n```java\npublic static void main(String[] args) {\n    Test test = Main::impl;    //使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现\n}\n\npublic static String impl(Integer i){\n    return \"我是已经存在的实现\"+i;\n}\n```\n\n> 定义：**方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。**\n\n常见的方法引用有三种：\n\n| **类型**               | **格式**       |\n| ---------------------------- | -------------------- |\n| 引用静态方法                 | `类名::静态方法名` |\n| 引用对象的实例方法           | `实例对象::方法名` |\n| 引用类型的任意对象的实例方法 | `类名::实例方法名` |\n\n事实上，Lambda 能够简化的一个依据就是函数式接口。\n\n函数式接口是一个只有一个抽象方法的接口，最开始的时候也叫做 **SAM 类型**的接口（`Single Abstract Method`）。它具有两个特点：\n\n1. **只包含一个抽象方法** ：函数式接口只能有一个抽象方法，但可以包含多个默认方法或静态方法。\n2. **用** **`@FunctionalInterface`** **注解标记** ：该注解不强制，但通常会使用它来标记该接口为函数式接口。这样做可以让编译器检查接口是否符合函数式接口的定义，以避免不必要的错误。\n\n所以， 从本质上来说 **Lambda 表达式就是一个函数式接口的实例** 。这就是 Lambda 表达式和函数式接口的关系。简单理解就是只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示。\n\n下面给出一个纯函数式接口的例子：\n\n```java\n@FunctionalInterface\npublic interface FunctionInterface {\n\n    /**\n     * 抽象方法\n     */\n    void doSomething();\n\n    /**\n     * 默认方法\n     * @param s\n     */\n    default void defaultMethod(String s) {\n        System.out.println(\"默认方法：\" + s);\n    }\n\n    /**\n     * 静态方法\n     * @param s\n     */\n    static void staticMethod(String s) {\n        System.out.println(\"静态方法：\" + s);\n    }\n}\n```\n\n使用如下：\n\n```java\n        FunctionInterface functionInterface = () -> {\n            System.out.println(\"死磕 Java 就是牛...\");\n        };\n\n        // 调用抽象方法\n        functionInterface.doSomething();\n        // 调用默认方法\n        functionInterface.defaultMethod(\"死磕 Netty 就是牛...\");\n        // 调用静态方法\n        FunctionInterface.staticMethod(\"死磕 Java 并发就是牛...\");\n```\n\nJava 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体可以看这篇博客：[Java 8 新特性—函数式接口 - 死磕 Java (skjava.com)](https://www.skjava.com/series/article/1841959591)\n\n### Optional解决空指针问题\n\nJava 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。\n\n```java\npublic static void hello(String str){   //现在我们要实现一个方法，将传入的字符串转换为小写并打印\n    System.out.println(str.toLowerCase());  //那太简单了吧，直接转换打印一气呵成\n}\n```\n\n但是这样实现的话，我们少考虑了一个问题，万一给进来的 `str`是 `null`呢？如果是 `null`的话，在调用 `toLowerCase`方法时岂不是直接空指针异常了？所以我们还得判空一下：\n\n```java\npublic static void hello(String str){\n    if(str != null) {\n        System.out.println(str.toLowerCase());\n    }\n}\n```\n\n这样写起来非常难受，思路正在头上的时候，经常会因为处理判空之类的问题，把自己的思路打乱，Optional类就可以解决这个问题：\n\n```java\npublic static void hello(String str){\n    Optional\n            .ofNullable(str)   //将str包装进Optional\n            .ifPresent(s -> {   //ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void）\n                System.out.println(s);   \n            });\n}\n```\n\n我们来看看Optional类的Api：\n\n```java\npublic final class Optional<T> {\n\n    /**\n     * 如果非空，则为该值；如果为空，则表示没有值存在。\n     */\n    private final T value;\n  \n    //...\n }\n```\n\n可以看出来，Optional 的本质就是内部存储了一个真实的值 T，如果 T 非空，就为该值，如果为空，则表示该值不存在。\n\n### 新的日期时间API\n\n原有的Java日期时间Api有这些问题：\n\n1. **线程不安全** ：`java.util.Date` 和 `java.util.Calendar` 线程不安全，这就导致我们在多线程环境使用需要额外注意。同时， `java.text.SimpleDateFormat` 也是线程不安全的，这可能导致性能问题和日期格式化错误。而且它的模式字符串容易出错，且不够直观。\n2. **可变性** ：`java.util.Date`类是可变的，这意味着我们可以随时修改它，如果一不小心就会导致数据不一致问题。\n3. **时区处理困难** ：Java 8 版本以前的日期 API 在时区处理上存在问题，例如时区转换和夏令时处理不够灵活和准确。而且时区信息在 `Date` 对象中存储不明确，这使得正确处理时区变得复杂。\n4. **设计不佳** ：日期和日期格式化分布在多个包中。`java.util.Date` 的默认日期，年竟然是从 1900 开始，月从 1 开始，日从 1 开始，没有统一性。而且 `java.util.Date` 类也缺少直接操作日期的相关方法。日期和时间处理通常需要大量的样板代码，使得代码变得冗长和难以维护。\n\n相比 Java 8 之前的版本，Java 8 版本的日期时间 API 具有如下几个优点：\n\n1. **不可变性（Immutability）** ：Java 8的日期时间类（如 `LocalDate`、`LocalTime`和 `LocalDateTime`）都是不可变的，一旦创建就不能被修改。这确保了 **线程安全** ，避免了并发问题。\n2. **清晰的API设计** ：Java 8 的日期时间 API 采用了更清晰、更一致的设计，相比于以前版本的 `Date` 和 `Calendar` 更易于理解和使用。而且它们还提供了丰富的方法来执行日期和时间的各种操作，如加减、比较、格式化等。\n3. **本地化支持** ：Java 8 的日期时间 API 支持本地化，可以轻松处理不同地区和语言的日期和时间格式。它们能够自动适应不同的时区和夏令时规则。\n4. **新的时区处理** ：Java 8引入了 `ZoneId` 和 `ZoneOffset` 等新的时区类，使时区处理更加精确和灵活。这有助于解决以前版本中时区处理的问题。\n5. **新的格式化API** ：Java 8引入了 `DateTimeFormatter` 类，用于格式化和解析日期和时间，支持自定义格式和本地化。这提供了更强大和灵活的格式化选项。\n6. **更好的性能** ：Java 8 的日期时间API 比以前的API 性能更佳。\n\n### Stream API 对元素流进行函数式操作\n\nJava 8 中两个最为重要的的更新：第一个是 [Lambda 表达式](https://www.skjava.com/series/article/1747461365)，另外一个就是 `Stream API`\n\n`Stream API` 是 Java 8 引入的一个用于对集合数据进行函数式编程操作的强大的库。它允许我们以一种更简洁、易读、高效的方式来处理集合数据，可以极大提高 Java 程序员的生产力，是目前为止对 Java 类库最好的补充。\n\n`Stream API` 的核心思想是将数据处理操作以函数式的方式链式连接，以便于执行各种操作，如过滤、映射、排序、归约等，而无需显式编写传统的循环代码。\n\n相比各种for循环，StreamAPI在CRUD技巧上实现了函数式编程，关注计算而非数据本身.\n\n一个完整的 Stream 操作包括三步\n\n#### 创建Stream\n\n首先我们需要一个 Stream 对象，常见的创建方式有：\n\n* 使用集合的 `stream()` 方法\n\n在集合中有两个方法可以创建 Stream 对象：\n\n```Java\ndefault Stream<E> stream()：返回一个顺序流\ndefault Stream<E> parallelStream()：返回一个并行流\n\n```\n\n* 通过数组\n\n`Arrays.stream(T[] array)`，将数组转换为 Stream 对象：\n\n```java\nString[] array = {\"Java\",\"Java 并发\",\"Java 虚拟机\"};\nStream<String> stream = Arrays.stream(array);\n```\n\n* 使用 `Stream.of(T... values)`方法\n\n```Java\nStream<String> stream = Stream.of(\"Java\",\"Java 并发\",\"Java 虚拟机\");\n\n```\n\n这种方式适用于直接提供一组元素来创建Stream。\n\n* 使用 `Stream.builder()`方法\n\nStream 提供了一个 `builder()` 方法来提供构建 Stream 的构造器：\n\n```Java\nStream.Builder<String> builder = Stream.builder();\nbuilder.accept(\"Java\");\nbuilder.accept(\"Java 并发\");\nbuilder.accept(\"Java 虚拟机\");\nStream<String> stream = builder.build();\n```\n\n这种方式适用于需要逐个添加元素到Stream中的情况。\n\n#### 中间操作\n\n有了 Stream 对象，就可以在 Stream 上应用中间操作。\n\n中间操作是一系列的操作，对数据源的数据进行处理，例如过滤、映射、排序、去重等等。注意这些操作不会立即执行，而是构建一个操作链。下表是 Stream 中常用中间操作方法。\n\n| 方法名                                     | 描述                                               |\n| ------------------------------------------ | -------------------------------------------------- |\n| `filter(Predicate<T> predicate)`         | 根据给定的谓词条件过滤元素。                       |\n| `map(Function<T, R> mapper)`             | 将元素通过给定的函数映射为另一个类型的元素。       |\n| `flatMap(Function<T, Stream<R>> mapper)` | 将每个元素映射为一个流，然后将这些流合并为一个流。 |\n| `distinct()`                             | 去除流中的重复元素。                               |\n| `sorted()`                               | 对元素进行排序，默认按自然顺序排序。               |\n| `sorted(Comparator<T> comparator)`       | 使用自定义比较器对元素进行排序。                   |\n| `limit(long maxSize)`                    | 截取流中的前 maxSize 个元素。                      |\n| `skip(long n)`                           | 跳过流中的前N个元素。                              |\n\n#### 终端操作\n\n做完中间操作后，我们需要调用一个终端操作来触发实际的数据处理。终端操作会遍历 Stream 并执行中间操作并产生结果。下表是一些常见的终端操作方法：\n\n| 方法名                                      | 方法描述                                                       |\n| ------------------------------------------- | -------------------------------------------------------------- |\n| `forEach()`                               | 对流中的每个元素执行指定的操作。                               |\n| `forEachOrdered()`                        | 与forEach类似，但保留了元素的顺序。                            |\n| `toArray()`                               | 将流中的元素收集到数组中。                                     |\n| `reduce(accumulator)`                     | 通过累积操作将流中的元素归约为单个结果。                       |\n| `reduce(identity, accumulator)`           | 使用初始值和累积操作将流中的元素归约为单个结果。               |\n| `reduce(identity, accumulator, combiner)` | 使用初始值、累积操作和组合操作将流中的元素归约为单个结果。     |\n| `collect()`                               | 将流中的元素收集到集合或映射中，可以指定收集器来定制收集行为。 |\n| `min(comparator)`                         | 使用指定的比较器找到流中的最小元素。                           |\n| `max(comparator)`                         | 使用指定的比较器找到流中的最大元素。                           |\n| `count()`                                 | 计算流中元素的数量。                                           |\n| `anyMatch()`                              | 检查流中是否有任何元素匹配指定的条件。                         |\n| `allMatch()`                              | 检查流中的所有元素是否都匹配指定的条件。                       |\n| `noneMatch()`                             | 检查流中是否没有元素匹配指定的条件。                           |\n| `findFirst()`                             | 返回流中的第一个元素（如果存在），通常与filter操作一起使用。   |\n| `findAny()`                               | 返回流中的任意元素（如果存在），通常与filter操作一起使用。     |\n\n### 其他特性\n\n除了上面介绍的主要特性（尤其是StreamAPI和）之外，Java 8的新特性还包括：\n\n* 日期格式化\n* 构造器引用\n* 重复注解@Repeatable\n* 异步类CompletableFuture\n* 类型注解\n* 接口默认方法与静态方法\n* 类型推断优化\n* Base64 API\n\n这些新特性在平时开发中也不用可以去学，时间长了自然会用上，总而言之，Java 8还是主要去掌握Stream API和Lambda函数式编程为要。\n","tags":["编程语言"],"categories":["Java新特性日志"]},{"title":"Sass入门初步","url":"/2024/10/12/Sass入门初步/","content":"今天换个口味，做一下样式表\n\n# 区分CSS，SCSS，SASS\n\n其实很长一段时间我都不知道SCSS和SASS为啥只需要安装：\n\n```bash\nnpm install sass\n```\n\n之后就都可以使用了，后来才发现这俩只是一个东西的两个版本罢了。。。\n\n### 一、CSS（Cascading [Style](https://so.csdn.net/so/search?q=Style&spm=1001.2101.3001.7020) Sheets）\n\nCSS 是一种用来描述 HTML 或 XML 文档外观和格式的样式表语言。它通过定义样式规则，来控制网页元素的呈现方式。CSS 语法相对简单，直接书写样式规则。每条规则包含选择器和一组声明，声明包括属性和值。\n\n```css\nbody {\n  font-family: Arial, sans-serif;\n  color: #333;\n}\n\nh1 {\n  color: #444;\n}\n\n```\n\n### 二、SASS（Syntactically Awesome Stylesheets）\n\nSass 是一个 CSS 预处理器，扩展了 CSS，添加了变量、嵌套规则、混入、继承等功能，增强了样式表的功能性和可维护性。Sass 有两种语法：缩进式语法（原始语法，文件扩展名为 `.sass`）和 SCSS 语法（CSS 超集，文件扩展名为 `.scss`）。\n\n```scss\n$primary-color: #333\n\nbody\n  font-family: Arial, sans-serif\n  color: $primary-color\n\nh1\n  color: darken($primary-color, 10%)\n\n```\n\n### 三、SCSS（Sassy CSS）\n\nSCSS 是 Sass 的一种语法，是 CSS 的超集，这意味着所有有效的 CSS 代码在 SCSS 中同样有效。它结合了 CSS 的简单性和 Sass 的强大功能。SCSS 语法与 CSS 类似，但引入了 Sass 的所有高级功能，如变量、嵌套、混入、继承等。\n\n```scss\n$primary-color: #333;\n\nbody {\n  font-family: Arial, sans-serif;\n  color: $primary-color;\n}\n\nh1 {\n  color: darken($primary-color, 10%);\n}\n\n```\n\n# Bem架构\n\n如今，有很多思想或者命名规范，例如：[OOCSS](https://link.zhihu.com/?target=http%3A//oocss.org/), [SMACSS](https://link.zhihu.com/?target=http%3A//smacss.com/), [SUITCSS](https://link.zhihu.com/?target=http%3A//suitcss.github.io/), [Atomic](https://link.zhihu.com/?target=https%3A//github.com/nemophrost/atomic-css)， 还有[BEM](https://link.zhihu.com/?target=http%3A//getbem.com/introduction/), 本文只讨论市面上比较流行的**BEM**规范，它由Yandex团队开发,其目标是帮助Developer更好的理解和抽象HTML和CSS之间的关系。\n\n**BEM**由**B**lock(块),**E**lement(元素),**M**odifer(修饰符)三部分组成。假设你的网站由不同的模块(组件)组成，那么对应到BEM规范里面，你的组件名为Block, 每个组件里面有不同的子项为Element, 如果你的组件或者子项，有特定的状态或者行为来修饰组件或者[子项](https://zhida.zhihu.com/search?content_id=113447052&content_type=Article&match_order=3&q=%E5%AD%90%E9%A1%B9&zhida_source=entity)，那么对应的是Modifer.下面会通过一些示例来讲解\n\n### 1.1 Block(块)\n\n**Block**是你网站中的一个模块或者组件，假设你网站中由Header,Content, Sidebar, Footer组件组成，那么他们都是Block,需要注意的是Block 是CSS[作用域链](https://zhida.zhihu.com/search?content_id=113447052&content_type=Article&match_order=1&q=%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE&zhida_source=entity)的顶端。\n\n```html\n// HTML \n<div id=\"website\">\n   <Header />\n   <Content />\n   <SideBar />\n   <Footer />\n</div>\n\n// Header component\n<div className=\"header\">Header</div>\n\n// Content component\n<div className=\"content\">Content</div>\n\n// Sidebar component\n<div className=\"sidebar\">Sidebar</div>\n\n// Footer component\n<div className=\"footer\">Footer</div>\n\n// CSS\n.header {\n    /* style * /\n}\n.content {\n    /* style * /\n}\n.sidebar {\n    /* style * /\n}\n.footer {\n    /* style * /\n}\n```\n\n### 1.2 Element(元素)\n\n**Element**代表的是**Block**中某一个特定的项，它通过 __ 与连接Block, \"__\"的意义是声明Element与Block之间的父子关系，例如Content 组件里面包含一个form 表单，包含一些描述信息的段落，等等。\n\n```html\n// HTML\n<div className=\"content\">\n   <form className=\"content__form\"></form>\n   <p className=\"content__description\"></p>\n   <div className=\"content__item\"></div>\n</div>\n//CSS\n.content__form{} //表达的意思是content 下的form\n.content__description{} //表达的意思是content 下的description\n.content__item{} //表达的意思是content 下的item\n```\n\n### 1.3 Modifier(修饰符)\n\n**Modifier**是用来描述**Block**或者**Element**的变体。它用\"--\"与**Block**或者**Element**连接，例如我们的Button 组件，它有很多的状态和外观，例如selected,default,disabled,按钮的颜色可能有green,red,orange.这些都属于Modifier.\n\n```html\n//HTML\n<div className=\"button button--{props.theme} button--{props.status}\"></div>\n\n//CSS\n.button--default{}\n.button--selected{}\n.button--disabled{}\n.button--green{}\n.button--red{}\n...\n```\n\nBEM 由 Block, Element, Mdifier 三部分组成。每个部分描述不同的意义。Elment 通过\"__\" 于 Block连接，它声明了父子关系。Modifier 通过\"--\"与Block或者Element连接，用来描述作用者的状态或者行为。\n\n **优点** :\n\n* \"__\"描述元素父子关系\n* 减少CSS层级嵌套问题\n* CSS与HTML的映射关系\n* 类名合乎逻辑且直观\n* 给团队提供了一种声明式语法\n\n**缺点**\n\n* 额外的学习成本\n* 类名变的更长\n* Block的抽象至关重要\n\n# 使用SCSS实现Bem架构\n\n在vite项目中创建一个 `bem.scss`文件：\n\nbem.scss\n\n```scss\n//命名空间\n$namespace: \"bem\" !default;\n\n//选择器 规则\n$block-sel: \"-\" !default;\n$elem-sel: \"__\" !default;\n$mod-sel: \"--\" !default;\n\n//css清除覆盖\n@mixin bfc{\n  height:100%;\n  overflow:hidden;\n}\n\n//块 混合器\n@mixin b($block) {\n  $B: #{$namespace + $block-sel + $block};\n  .#{$B} {\n    @content;\n  }\n}\n\n//元素 混合器\n@mixin e($el) {\n  $selector: &;\n  @at-root {\n    #{$selector + $elem-sel + $el} {\n      @content;\n    }\n  }\n}\n\n//修饰 混合器\n@mixin m($m) {\n  $selector: &;\n  @at-root {\n    #{$selector + $mod-sel + $m} {\n      @content;\n    }\n  }\n}\n```\n\n咋使用呢？参考这个例子：\n\n```html\n<template>\n    <div class=\"bem-menu\">\n        <h1>Menu</h1>\n        <div class=\"bem-menu__list\">\n            <ul class=\"bem-menu__ul\">\n                <li class=\"bem-menu__item\">Home</li>\n                <li class=\"bem-menu__item\">About</li>\n                <li class=\"bem-menu__item\">Contact</li>\n            </ul>\n        </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, reactive } from 'vue'\n\n</script>\n\n<style lang=\"scss\" scoped>\n@include b(menu) {\n    min-width: 300px;\n    border-right: 1px solid #ccc;\n    height: 100%;\n\n    @include e(list){\n        height: 100%;\n        overflow-y: auto;\n    }\n\n    @include e(ul){\n        list-style: none;\n        margin: 0;\n        padding: 0;\n    }\n\n    @include e(item){\n        padding: 10px;\n        cursor: pointer;\n        transition: background-color 0.3s ease;\n\n        &:hover{\n            background-color: #f5f5f5;\n        }\n    }\n}\n</style>\n```\n\n# 自顶向下认识SCSS\n\n从上面的例子可以发现scss几个基本的功能：\n\n### 一、嵌套CSS\n\n可以看到我们用@include的时候，@include里面也可以用@include，也就是说，css可以按照树形结构进行嵌套。\n\n原版css中是这样的：\n\n```css\n#content article h1 { color: #333 }\n#content article p { margin-bottom: 1.4em }\n#content aside { background-color: #EEE }\n```\n\nscss中可以这样写：\n\n```scss\n#content {\n  article {\n    h1 { color: #333 }\n    p { margin-bottom: 1.4em }\n  }\n  aside { background-color: #EEE }\n}\n```\n\n### 二、模块化导入\n\n> `css`有一个特别不常用的特性，即 `@import`规则，它允许在一个 `css`文件中导入其他 `css`文件。然而，后果是只有执行到 `@import`时，浏览器才会去下载其他 `css`文件，这导致页面加载起来特别慢。\n>\n> `sass`也有一个 `@import`规则，但不同的是，`sass`的 `@import`规则在生成 `css`文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个 `css`文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器（参见2.5节）均可在导入文件中使用。\n\n### 三、混合器mixer\n\n一个这样的混合器\n\n```scss\n@mixin rounded-corners {\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  border-radius: 5px;\n}\n```\n\n可以这样使用：\n\n```scss\nnotice {\n  background-color: green;\n  border: 2px solid #00aa00;\n  @include rounded-corners;\n}\n\n//编译后：\n.notice {\n  background-color: green;\n  border: 2px solid #00aa00;\n  -moz-border-radius: 5px;\n  -webkit-border-radius: 5px;\n  border-radius: 5px;\n}\n```\n\n除此之外，还有其他的特性，在这里就不做介绍了，这里只介绍简单的开发能用上的一些特性。\n","tags":["前端"]},{"title":"Vue重学计划（五）","url":"/2024/10/11/Vue重学计划（五）/","content":"今日状态不错，特此奖励自己下午写博客一篇\n\n昨天聊完了computed，今天来聊聊watch和watchEffect\n\n# 使用Watch\n\n```html\n<template>\n    <div>\n        case1:<input type=\"text\" v-model=\"message\">\n        <hr>\n        case2:<input type=\"text\" v-model=\"message2\">\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, reactive, watch } from 'vue'\n\nlet message = ref<string>('Hello Vue 3')\n\nlet message2 = ref<string>('Hello TypeScript')\n\nwatch([message, message2], (newVal, oldVal) => {\n    console.log('newVal:', newVal, 'oldVal:', oldVal)\n})\n</script>\n\n<style lang=\"css\" scoped></style>\n```\n\n> watch需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生变化时被调用。\n\nwatch的用法比较简单，说白了就是我们常说的监听器，有的地方叫Listener，有的地方叫Subscriber，其实无所谓。\n\n不过watch的源码还是值得一看的，而且Vue3最近的更新中，watch和watchEffect也是重构过了\n\n# 使用WatchEffect\n\n```html\n<template>\n    <input type=\"text\" v-model=\"message\">\n    <input type=\"text\" v-model=\"message2\">\n    <p>{{ message }} {{ message2 }}</p>\n    <button @click=\"stop\">Stop Watching</button>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, watchEffect } from 'vue'\n\nlet message = ref<string>(\"Genshin Impact\")\n\nlet message2 = ref<string>(\"Genshin\")\n\nconst stop = watchEffect((oninvalidate) => {\n\n    console.log('message changed to:', message.value)\n    oninvalidate(() => {\n        console.log('before message changed')\n    })\n})\n\nconst \n</script>\n\n<style lang=\"css\" scoped></style>\n```\n\n立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。\n\n# 区别\n\n> * **执行时机** ：watchEffect是立即执行的，在页面加载时会主动执行一次，来收集依赖；而watch是惰性地执行副作用，它不会立即执行，但可以配置 immediate，使其主动触发\n>\n> ```javascript\n>  watchEffect(() => {\n>        console.log(test.value)\n>  })\n>  watch (test.value,(val,oldval) => {\n>        console.log(val)\n>  },{ immediate: true })\n>  //效果差不多\n>\n> ```\n>\n> * **参数不同** ：watchEffect只需要传递一个回调函数，不需要传递侦听的数据，它会在页面加载时主动执行一次，来收集依赖；而watch至少要有两个参数（第三个参数是配置项），第一个参数是侦听的数据，第二个参数是回调函数\n> * **结果不同** ：watchEffect获取不到更改前的值；而watch可以同时获取更改前和更改后的值\n\n简单一句话，`watch` 功能更加强大，而 `watchEffect` 在某些场景下更加简洁。\n\n# 源码解析\n\nVue3的源码也是最近经过重构过的，在 `@vue/reactive/watch.ts`和 `@vue/runtime-core/apiWatch.ts`中可以看到。\n\n我们在 `apiWatch.ts`中可以看到这三个开放的api接口以及实现中，都调用了doWatch:\n\napi部分\n\n```typescript\n// Simple effect.\nexport function watchEffect(\n  effect: WatchEffect,\n  options?: WatchEffectOptions,\n): WatchHandle {\n  return doWatch(effect, null, options)\n}\n\nexport function watchPostEffect(\n  effect: WatchEffect,\n  options?: DebuggerOptions,\n): WatchHandle {\n  return doWatch(\n    effect,\n    null,\n    __DEV__ ? extend({}, options as any, { flush: 'post' }) : { flush: 'post' },\n  )\n}\n\nexport function watchSyncEffect(\n  effect: WatchEffect,\n  options?: DebuggerOptions,\n): WatchHandle {\n  return doWatch(\n    effect,\n    null,\n    __DEV__ ? extend({}, options as any, { flush: 'sync' }) : { flush: 'sync' },\n  )\n}\n```\n\n实现部分\n\n```typescript\n// implementation\nexport function watch<T = any, Immediate extends Readonly<boolean> = false>(\n  source: T | WatchSource<T>,\n  cb: any,\n  options?: WatchOptions<Immediate>,\n): WatchHandle {\n  if (__DEV__ && !isFunction(cb)) {\n    warn(\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\n        `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\n        `supports \\`watch(source, cb, options?) signature.`,\n    )\n  }\n  return doWatch(source as any, cb, options)\n}\n```\n\n顺着找到 `watch.ts`中的watch函数，可以看到：\n\n```typescript\nexport function watch(\n  source: WatchSource | WatchSource[] | WatchEffect | object,\n  cb?: WatchCallback | null,\n  options: WatchOptions = EMPTY_OBJ,\n): WatchHandle {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options\n\n  const warnInvalidSource = (s: unknown) => {\n    ;(options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, ` +\n        `a reactive object, or an array of these types.`,\n    )\n  }\n\n  const reactiveGetter = (source: object) => {\n    // traverse will happen in wrapped getter below\n    if (deep) return source\n    // for `deep: false | 0` or shallow reactive, only traverse root-level properties\n    if (isShallow(source) || deep === false || deep === 0)\n      return traverse(source, 1)\n    // for `deep: undefined` on a reactive object, deeply traverse all properties\n    return traverse(source)\n  }\n\n  let effect: ReactiveEffect\n  let getter: () => any\n  let cleanup: (() => void) | undefined\n  let boundCleanup: typeof onWatcherCleanup\n  let forceTrigger = false\n  let isMultiSource = false\n\n  if (isRef(source)) {\n    getter = () => source.value\n    forceTrigger = isShallow(source)\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source)\n    forceTrigger = true\n  } else if (isArray(source)) {\n    isMultiSource = true\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s))\n    getter = () =>\n      source.map(s => {\n        if (isRef(s)) {\n          return s.value\n        } else if (isReactive(s)) {\n          return reactiveGetter(s)\n        } else if (isFunction(s)) {\n          return call ? call(s, WatchErrorCodes.WATCH_GETTER) : s()\n        } else {\n          __DEV__ && warnInvalidSource(s)\n        }\n      })\n  } else if (isFunction(source)) {\n    if (cb) {\n      // getter with cb\n      getter = call\n        ? () => call(source, WatchErrorCodes.WATCH_GETTER)\n        : (source as () => any)\n    } else {\n      // no cb -> simple effect\n      getter = () => {\n        if (cleanup) {\n          pauseTracking()\n          try {\n            cleanup()\n          } finally {\n            resetTracking()\n          }\n        }\n        const currentEffect = activeWatcher\n        activeWatcher = effect\n        try {\n          return call\n            ? call(source, WatchErrorCodes.WATCH_CALLBACK, [boundCleanup])\n            : source(boundCleanup)\n        } finally {\n          activeWatcher = currentEffect\n        }\n      }\n    }\n  } else {\n    getter = NOOP\n    __DEV__ && warnInvalidSource(source)\n  }\n\n  if (cb && deep) {\n    const baseGetter = getter\n    const depth = deep === true ? Infinity : deep\n    getter = () => traverse(baseGetter(), depth)\n  }\n\n  const scope = getCurrentScope()\n  const watchHandle: WatchHandle = () => {\n    effect.stop()\n    if (scope) {\n      remove(scope.effects, effect)\n    }\n  }\n\n  if (once && cb) {\n    const _cb = cb\n    cb = (...args) => {\n      _cb(...args)\n      watchHandle()\n    }\n  }\n\n  let oldValue: any = isMultiSource\n    ? new Array((source as []).length).fill(INITIAL_WATCHER_VALUE)\n    : INITIAL_WATCHER_VALUE\n\n  const job = (immediateFirstRun?: boolean) => {\n    if (\n      !(effect.flags & EffectFlags.ACTIVE) ||\n      (!effect.dirty && !immediateFirstRun)\n    ) {\n      return\n    }\n    if (cb) {\n      // watch(source, cb)\n      const newValue = effect.run()\n      if (\n        deep ||\n        forceTrigger ||\n        (isMultiSource\n          ? (newValue as any[]).some((v, i) => hasChanged(v, oldValue[i]))\n          : hasChanged(newValue, oldValue))\n      ) {\n        // cleanup before running cb again\n        if (cleanup) {\n          cleanup()\n        }\n        const currentWatcher = activeWatcher\n        activeWatcher = effect\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE\n              ? undefined\n              : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE\n                ? []\n                : oldValue,\n            boundCleanup,\n          ]\n          call\n            ? call(cb!, WatchErrorCodes.WATCH_CALLBACK, args)\n            : // @ts-expect-error\n              cb!(...args)\n          oldValue = newValue\n        } finally {\n          activeWatcher = currentWatcher\n        }\n      }\n    } else {\n      // watchEffect\n      effect.run()\n    }\n  }\n\n  if (augmentJob) {\n    augmentJob(job)\n  }\n\n  effect = new ReactiveEffect(getter)\n\n  effect.scheduler = scheduler\n    ? () => scheduler(job, false)\n    : (job as EffectScheduler)\n\n  boundCleanup = fn => onWatcherCleanup(fn, false, effect)\n\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect)\n    if (cleanups) {\n      if (call) {\n        call(cleanups, WatchErrorCodes.WATCH_CLEANUP)\n      } else {\n        for (const cleanup of cleanups) cleanup()\n      }\n      cleanupMap.delete(effect)\n    }\n  }\n\n  if (__DEV__) {\n    effect.onTrack = options.onTrack\n    effect.onTrigger = options.onTrigger\n  }\n\n  // initial run\n  if (cb) {\n    if (immediate) {\n      job(true)\n    } else {\n      oldValue = effect.run()\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true)\n  } else {\n    effect.run()\n  }\n\n  watchHandle.pause = effect.pause.bind(effect)\n  watchHandle.resume = effect.resume.bind(effect)\n  watchHandle.stop = watchHandle\n\n  return watchHandle\n}\n```\n\n所有的实现和api都可以接收函数，ref，数组，基本的实现逻辑就是挂载一个副作用上去进行调用，同时immediate属性会取消懒加载，在初次进入的时候就可以调用。\n\n所以watchEffect说白了可以当作一种简写。。。\n\n再观察所有的api，调用doWatch之后，返回值类型都是WatchHandler，这个类型是这样的：\n\n```typescript\nexport type WatchStopHandle = () => void\n\nexport interface WatchHandle extends WatchStopHandle {\n  pause: () => void\n  resume: () => void\n  stop: () => void\n}\n```\n\n没错，这就是vue3取消监听的方法。当我们手动调用这个watch监听器的时候，我们就是在调用返回的这个WatchHandle中的函数，所以在调用之后，监听就会停止。\n\nbaseWatch中是这样实现的：\n\n```typescript\nconst watchHandle: WatchHandle = () => {\n    effect.stop()\n    if (scope) {\n      remove(scope.effects, effect)\n    }\n}\n```\n\n当副作用停止，监听自然也停止了。以后可以学学这个\"句柄Handler\"的使用方法。\n","tags":["前端"],"categories":["Vue3重学计划"]},{"title":"Vue重学计划（四）","url":"/2024/10/10/Vue重学计划（四）/","content":"今天状态不错，再写一篇，这样把之前欠的也算补回来了一点。\n\n简单把Computed总结一下\n\n# Computed用法\n\ncomputedDemo.vue\n\n```html\n<template>\n    <form>\n        <input type=\"text\" v-model=\"firstName\" />\n        <br>\n        <label>First Name:{{ firstName }}</label>\n        <br>\n        <input type=\"text\" v-model=\"lastName\" />\n        <br>\n        <label>Last Name:{{ lastName }}</label>\n        <p>Full Name: {{ fullName }}</p>\n        <button @click.prevent=\"submit\">submit</button>\n    </form>\n    <hr>\n    <form>\n        <input type=\"text\" v-model=\"upperBody\" />\n        <br>\n        <label>Upper Body:{{ upperBody }}</label>\n        <br>\n        <input type=\"text\" v-model=\"lowerBody\" />\n        <br>\n        <label>Lower Body:{{ lowerBody }}</label>\n        <p>People: {{ people }}</p>\n        <button @click.prevent=\"createPerson\">create person</button>\n    </form>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, reactive, computed } from 'vue'\n//  函数式写法 getter + private setter\nconst firstName = ref('')\nconst lastName = ref('')\nconst fullName = computed<string>(() => `${firstName.value} ${lastName.value}`)\nconst submit = () => {\n    console.log(fullName.value)\n}\n\n//  对象式写法 getter + setter\nconst upperBody = ref('')\nconst lowerBody = ref('')\nlet people = computed<string>({\n    get() {\n        return `${upperBody.value} ${lowerBody.value}`\n    },\n    set(newVal) {\n        [upperBody.value, lowerBody.value] = newVal.split(' ')\n    }\n})\nconst createPerson = () => {\n    people.value = '五条 悟'\n}\n</script>\n\n<style lang=\"css\" scoped></style>\n```\n\n这里面比较重要的就是computed的对象式写法，对象式写法需要在computed的参数中传入一个含有getter和setter的对象。\n\n常规的函数式写法的优势就是简明，使用对象式写法的优势是可以调用setter进行特殊处理，不过简单的开发里面很难用上就是了。\n\n# Computed实例\n\ncomputedDemo2.vue\n\n```html\n<template>\n    <div>\n        <input v-model=\"searchText\" placeholder=\"Search...\" type=\"text\">\n    </div>\n    <div style=\"margin-top: 20px;\">\n        <table>\n            <thead>\n                <tr>\n                    <th>ID</th>\n                    <th>Name</th>\n                    <th>Grade</th>\n                    <th>Passed</th>\n                    <th>Action</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr v-for=\"item in searchData\">\n                    <td align=\"center\">{{ item.id }}</td>\n                    <td align=\"center\">{{ item.name }}</td>\n                    <td align=\"center\">\n                        <button @click=\"item.grade < 100 ? item.grade++ : ''\">+</button>\n                        {{ item.grade }}\n                        <button @click=\"item.grade > 0 ? item.grade-- : ''\">-</button>\n                    </td>\n                    <td align=\"center\">\n                        {{ item.grade >= 60 ? 'Yes√' : 'No×' }}\n                    </td>\n                    <td align=\"center\">\n                        <button @click=\"deleteItem(item)\">Delete</button>\n                    </td>\n                </tr>\n            </tbody>\n            <tfoot>\n                <tr>\n                    <td colspan=\"5\" align=\"center\">\n                        通过的学生数：{{ total }}\n                    </td>\n                </tr>\n            </tfoot>\n        </table>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, reactive, computed } from 'vue'\nlet searchText = ref<string>('')\ninterface Student {\n    id: number,\n    name: string,\n    grade: number\n}\nlet data = reactive<Student[]>([\n    {\n        id: 1,\n        name: 'Tom',\n        grade: 90\n    },\n    {\n        id: 2,\n        name: 'Jerry',\n        grade: 80\n    },\n    {\n        id: 3,\n        name: 'Lily',\n        grade: 70\n    },\n    {\n        id: 4,\n        name: 'Lucy',\n        grade: 60\n    },\n    {\n        id: 5,\n        name: 'Mary',\n        grade: 50\n    },\n    {\n        id: 6,\n        name: 'FurryMonster',\n        grade: 0\n    }\n])\nconst searchData = computed(() => {\n    return data.filter((item: Student) => {\n        return item.name.includes(searchText.value)\n    })\n})\nfunction deleteItem(item: Student) {\n    data.splice(data.indexOf(item), 1)\n}\n// const total = () => {\n//     $total.value = data.reduce((prev: number, next: Student) => {\n//         return prev + Math.floor(next.grade / 60)\n//     }, 0)\n// }\nconst total = computed(() => {\n    return searchData.value.reduce((prev: number, next: Student) => {\n        return prev + Math.floor(next.grade / 60)\n    }, 0)\n})\n</script>\n\n<style lang=\"css\" scoped></style>\n```\n\n使用computed对searchData和total进行代理，双向绑定让我们不需要每次对每次重新渲染的时候都手动调用函数，函数的调用在绑定后由框架代理，能让我们更集中在业务逻辑的实现上.\n\n# Computed源码\n\nComputed源码比较简单，网上有很多源码解析版本很老了，Computed还是那种使用effect实现的版本，当前版本的vue3的computed早就不使用effect了，后面会专门出一期Vue3响应式的源码重写，这里就不多bb了\n","tags":["前端"],"categories":["Vue3重学计划"]},{"title":"Unity手动混合Animator动画","url":"/2024/10/10/Unity手动混合Animator动画/","content":"## 一、粗略认识一下两个用来混合的方法\n\n之前接触过Animator里内置的混合树BlendTree，虽然好用，但是因为依附于Animator存在，所以也不是太喜欢。\n\n最近研究Animator代码的时候偶然发现两个方法：\n\n### **CrossFade**和**CrossFadeInFixedTime**\n\n### （ ~看名字也能猜出来应该是用来混合动画的吧~ ）\n\n翻了一下官方文档，用人话翻译一下就是：\n\n> CrossFade是按照动画的自身时间进行混合。如果动画10秒，混合持续时间0.2，会在2秒后混合完成\n> CrossFadeInFixedTime是按照实际时间进行混合。如果动画10秒，混合持续时间0.2，会在0.2秒后混合完成\n>\n> 还有一个特性：使用CrossFade或CrossFadeInFixedTime混合时，如果混合时间大于动画自身长度，动画自身会被滞留在最后一帧，直到混合结束。\n>\n> 所以作为一种trick，也不是不能把这个东西当成动画播放的冷却器。。。\n\n## 二、详细了解一下这俩方法\n\n 其实真正使用的时候， **了解上面的内容，学会咋调用其实就够了** ，但是毕竟是记录学习的博客，还是把内容都记录下来吧，也算是逼迫自己多学习一点了。\n\n    官方文档的介绍如下：\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/77f2e1bed982ec04bd30fb9551cb8b39.png \"CrossFadeInFixed介绍\")\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/23625f32db28ae8a113a79c6ee6b4d38.png \"CrossFade\")\n\n看完了粗略概括一下就是：\n\n| 形参                               | 作用                                                                     |\n| ---------------------------------- | ------------------------------------------------------------------------ |\n| stateName/stateHashName            | 想过渡过去的状态名字（我还是推荐使用Hash）                               |\n| fixed/normalizedTransitionDuration | 过渡到该动画状态的混合时间（视原始动画而定，要么数值要么比例，自行斟酌） |\n| layer                              | 发生交叉淡入淡出的图层（在Animator里设置的那个玩意）                     |\n| fixed/normalizedTimeOffset         | 从多远的地方开始混合（也就是常说的偏移量）                               |\n| normalizedTransitionTime           | 混合已经进行了多少（就是我们的混合结果从什么位置开始被播放）             |\n\n**实话实说这个Unity文档写的是真的垃圾。。。后面的两个函数签名解释了个寂寞。。。害得我找了好久的解释** 。\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/76aa40e1647edddc7102962a959dcf2b.png)\n\n这是社区里我觉得比较通俗的解释，可以去[Unity社区](https://forum.unity.com/threads/what-is-the-animator-crossfade-normalizedtransitiontime.744629/ \"社区\")看看。\n\n## 三、关于后三个时间参数的理解\n\n假设我们有从A->B进行混合过渡，\n\nA状态持续1s，B状态持续2s，[调用函数](https://so.csdn.net/so/search?q=%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)：\n\n```csharp\nCrossFade（\"B\"， 0.2f， BaseLayer， 0.05f，0.1f）;\n```\n\n我们来逐层分析计算，\n\n0.2f表示我们的混合会使用20%的动画时间来混合\n\n0.05f表示这个混合从动画播放了5%的地方开始取，也就是混合5%到25%的部分\n\n这个时候我们会得到一个时间为(25% * 2) = 0.5s的混合动画，这个动画会在动画过渡的时候播放\n\n0.1f也就是表示，当我们播放这个0.5s的混合动画，会从（10% * 0.5s）= 0.05s的地方开始播放。\n\n大概就是这样一回事了，最后我还是要吐槽一句Unity的文档真的该更新了。。。写的太潦草了吧。。。\n\n如果有错误也请大佬们指出来了(\n","tags":["Unity"]},{"title":"Vue重学计划（三）","url":"/2024/10/10/Vue重学计划（三）/","content":"这周因为学校的事太多，耽误了好久，花了一天把Vue3的响应式数据整理了一下。\n\n~~感觉太迷茫了，现在就是在岔路口做决策，摇摆不定了。。。~~\n\n不知道咋办，还是先学习吧\n\n简单用一个Demo过一下基本的使用吧！\n\nmain.ts\n\n```typescript\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n```\n\nApp.vue\n\n```html\n<template>\n  <RefDemo />\n  <hr>\n  <hr>\n  <ReactiveDemo />\n  <hr>\n  <hr>\n  <ToDemo />\n</template>\n\n<script setup lang=\"ts\">\nimport ReactiveDemo from './components/reactiveDemo.vue';\nimport RefDemo from './components/refDemo.vue'\nimport ToDemo from './components/toDemo.vue';\n</script>'\n```\n\n# Ref相关\n\nrefDemo.vue\n\n```html\n<style lang=\"css\" scoped>\n.alive {\n  color: greenyellow;\n}\n\n.dead {\n  color: red;\n}\n</style>\n\n<template>\n  <div>\n    {{ Kevin }}\n  </div>\n  <div>\n    {{ Elysia }}\n  </div>\n  <hr>\n  <div>\n    {{ Mobius }}\n  </div>\n  <hr>\n  <button @click=\"Omega\">Omega Befalling</button>\n  <hr>\n  <button @click=\"Alpha\">Restarting new era</button>\n  <hr>\n  <button @click=\"toggle\">Toggle Kevin</button>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, customRef, shallowRef, Ref, triggerRef } from 'vue'\n\ninterface Hero {\n  name: string\n  power: string\n  weapon: string\n  rank: number\n  state: string\n}\n\nconst Kevin: Ref<Hero> = shallowRef({\n  name: 'Kevin',\n  power: 'Ice',\n  weapon: 'God Fire',\n  rank: 1,\n  state: 'Alive'\n})\n\nconst Elysia: Ref<Hero> = ref({\n  name: 'Elysia',\n  power: 'Crystal',\n  weapon: 'Key of Humanity',\n  rank: 2,\n  state: 'Alive'\n})\n\nconst Mobius: Ref<Hero> = ref({\n  name: 'Mobius',\n  power: 'Snake',\n  weapon: 'Shadow of passed world',\n  rank: 10,\n  state: 'Alive'\n})\n\nfunction Omega(): void {\n  Elysia.value.state = 'Dead'\n  Mobius.value.state = 'Dead'\n  console.log('我什么都做不到')\n}\n\nfunction Alpha(): void {\n  Kevin.value.state = 'Missing'\n  // 这里不要使用下面的句子，ref和shallowRef混用会导致浅层响应式失效\n  // Mobius.value.state = 'Missing'\n  console.log('人类，一定会战胜崩坏')\n}\n\nfunction toggle(): void {\n  Kevin.value.state = Kevin.value.state === 'Alive' ? 'Missing' : 'Alive'\n  triggerRef(Kevin)\n  console.log('Kevin triggered')\n}\n\n// 下面演示一下自定义Ref（customRef）的用法\nfunction MyRef<T>(value: T) {\n  return customRef((tracker, trigger) => {\n    return {\n      get() {\n        tracker()\n        return value\n      },\n      set(newValue: T) {\n        value = newValue\n        trigger()\n      }\n    }\n  })\n}\n\nconst Kiana = MyRef({\n  name: 'Kiana',\n  power: 'x',\n  weapon: 'y',\n  state: 'Alive'\n})\n</script>\n```\n\n## PS:\n\nshallowRef和Ref不要混用，Ref在重新更新渲染的时候，会导致shallowRef的渲染也被更新，shallow属性就失效了\n\n# Reactive相关\n\nreactiveDemo.vue\n\n```html\n<style lang=\"css\" scoped></style>\n\n<template>\n    <div>\n        <ul>\n            <li v-for=\"item in list.arr\">{{ item }}</li>\n        </ul>\n        <button @click.prevent=\"add\">add</button>\n        <hr>\n        <button @click=\"show\">Show Numbers</button>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, reactive, readonly } from 'vue'\n\nlet list = reactive<{\n    arr: string[]\n}>({\n    arr: []\n})\n\nlet numList = reactive<{\n    element: number[]\n    otherElement: string[]\n}>({\n    element: [1, 2, 3],\n    otherElement: ['a', 'b', 'c']\n})\nconst readonlyNumList = readonly(numList)\n\nconst add = () => {\n    setTimeout(() => {\n        let res = ['grape', 'mango', 'strawberry']\n        list.arr = res\n        console.log(list)\n    }, 2000)\n}\n\nconst show = () => {\n    console.log(numList.element, readonlyNumList.element)\n}\n</script>\n```\n\n## PS:\n\nreadonly只能用在reactive数据上\n\n调试可以发现，这个readonly的机制和响应式类似，都是使用proxy来进行\n\n# toRef相关\n\ntoDemo.vue\n\n```html\n<template>\n    <div>\n        {{ furrymonster }}\n    </div>\n    <hr>\n    <div>\n        toRef:{{ fav }}\n    </div>\n    <hr>\n    <div>\n        <button @click=\"change\">Change</button>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { toRef, reactive, toRefs, toRaw } from 'vue';\n\nconst furrymonster = reactive({ name: 'FurryMonster', age: '20', fav: 'jerk off' })\n\nconst fav = toRef(furrymonster, 'fav')\n\n\n\nconst change = () => {\n    furrymonster.fav = 'eat'\n    console.log(furrymonster)\n}\n</script>\n\n<style lang=\"css\">\n* {\n    padding: 0;\n    margin: 0;\n}\n</style>\n```\n\n## PS:\n\ntoRef和toRaw都是基于reactive的，对于普通的对象，这两个函数不会发挥任何作用\n\n从这里也不难发现，Vue3的ref基于reactive，reactive基于对普通数据（raw data）的proxy代理，它们之间是一个相互依赖的关系\n\n# 响应式原理\n\n\n\nVue2 使用的是 Object.defineProperty  [Vue3](https://so.csdn.net/so/search?q=Vue3&spm=1001.2101.3001.7020) 使用的是 Proxy\n\n#### reactive和effect的实现\n\n```typescript\nexport const reactive = <T extends object>(target:T) => {\n    return new Proxy(target,{\n        get (target,key,receiver) {\n          const res  = Reflect.get(target,key,receiver) as object\n \n          return res\n        },\n        set (target,key,value,receiver) {\n           const res = Reflect.set(target,key,value,receiver)\n \n           return res\n        }\n    })\n}\n```\n\nVue3 的响应式原理依赖了 Proxy 这个核心 API，通过 Proxy 可以劫持对象的某些操作。\n\n#### effect track trigger\n\n实现effect 副作用函数\n\n```typescript\nlet activeEffect;\nexport const effect = (fn:Function) => {\n     const _effect = function () {\n        activeEffect = _effect;\n        fn()\n     }\n     _effect()\n}\n```\n\n使用一个全局变量 active 收集当前副作用函数，并且初始化的时候调用一下\n\n实现track\n\n```typescript\nconst targetMap = new WeakMap()\nexport const track = (target,key) =>{\n   let depsMap = targetMap.get(target)\n   if(!depsMap){\n       depsMap = new Map()\n       targetMap.set(target,depsMap)\n   }\n   let deps = depsMap.get(key)\n   if(!deps){\n      deps = new Set()\n      depsMap.set(key,deps)\n   }\n \n   deps.add(activeEffect)\n}\n```\n\n执行完成成后我们得到一个如下的数据结构\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/37cb1779ae1ca34629f5614eccabc2e5.png)\n\n实现trigger\n\n```typescript\nexport const trigger = (target,key) => {\n   const depsMap = targetMap.get(target)\n   const deps = depsMap.get(key)\n   deps.forEach(effect=>effect())\n}\n```\n\n当我们进行赋值的时候会调用 set 然后 触发收集的副作用函数\n\n```typescript\nimport {track,trigger} from './effect'\n \nexport const reactive = <T extends object>(target:T) => {\n    return new Proxy(target,{\n        get (target,key,receiver) {\n          const res  = Reflect.get(target,key,receiver) as object\n \n          track(target,key)\n \n          return res\n        },\n        set (target,key,value,receiver) {\n           const res = Reflect.set(target,key,value,receiver)\n \n           trigger(target,key)\n \n           return res\n        }\n    })\n}\n```\n\n给 reactive 添加这两个方法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n \n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n \n<body>\n \n    <div id=\"app\">\n \n    </div>\n \n    <script type=\"module\">\n        import { reactive } from './reactive.js'\n        import { effect } from './effect.js'\n        const user = reactive({\n            name: \"小满\",\n            age: 18\n        })\n        effect(() => {\n            document.querySelector('#app').innerText = `${user.name} - ${user.age}`\n        })\n \n        setTimeout(()=>{\n            user.name = '大满很吊'\n            setTimeout(()=>{\n                user.age = '23'\n            },1000)\n        },2000)\n \n    </script>\n</body>\n \n</html>\n```\n\n#### 递归实现reactive\n\n```typescript\nimport { track, trigger } from './effect'\n \nconst isObject = (target) => target != null && typeof target == 'object'\n \nexport const reactive = <T extends object>(target: T) => {\n    return new Proxy(target, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver) as object\n \n            track(target, key)\n \n            if (isObject(res)) {\n                return reactive(res)\n            }\n \n            return res\n        },\n        set(target, key, value, receiver) {\n            const res = Reflect.set(target, key, value, receiver)\n \n            trigger(target, key)\n \n            return res\n        }\n    })\n}\n```\n","tags":["前端"],"categories":["Vue3重学计划"]},{"title":"DevOps","url":"/2024/10/08/DevOps/","content":"### 概述\n\nDevOps是软件开发 (Development) 和运营 (Operations) 的结合。Gartner 咨询公司认为 DevOps 代表了 IT 文化的变化趋势。DevOps 可以最好地解释为人们一起工作以最快的速度构思、构建和交付安全软件。DevOps 实践使软件开发 (dev) 和运营 (ops) 团队能够通过自动化、协作、快速反馈和迭代改进来加速交付。代表着重视「软件开发人员(Dev)」和「IT 运维技术人员(Ops)」之间沟通合作的文化；旨在透过自动化「软件交付」和「架构变更」的流程，使得构建、 测试、发布软件的过程能够更加地快捷、频繁和可靠。\n\n\n### DevOps的好处\n\nDevOps 打破了障碍，使开发和运营团队不再孤立，并且可以更有效地跨整个开发和应用程序生命周期开展工作。如果没有 DevOps，组织通常会遇到交接摩擦，这会延迟软件发布的交付并对业务结果产生负面影响。\n\n采用 DevOps 的文化、做法和工具的团队能够提升效率，以更快的速度构建更好的产品，从而获得更高的客户满意度。若要实现以下业务目标，这种改进的协作方式和生产能力不可或缺：缩短上市时间、适应市场和竞争、保持系统稳定性和可靠性、缩短平均恢复时间。\n\n### DevOps 文化\n\n采用 DevOps 做法可以通过技术来实现流程的自动化和优化，但这一切都需要从组织内部的文化和参与的人员开始。培养 DevOps 文化的挑战在于需要深入改变人们的工作和协作方式。但是，通过推行 DevOps 文化，组织可以创造一个有利于高绩效团队成长的环境。\n\n协作、可见性和一致性：健康的 DevOps 文化的一个标志是团队间能够协作，首要的便是可见性。开发和 IT 运营等不同团队必须能够相互分享 DevOps 流程、优先级和关注点。这些团队还必须能够共同规划工作，并统一与业务相关的成功目标和衡量标准。\n\n1. 范围和责任的转变：当团队统一时，他们拥有所有权并参与其他生命周期阶段，而不仅仅是他们的角色对应的阶段。例如，开发人员不仅要对开发阶段的创新和质量负责，还要对他们的改变在运营阶段带来的性能和稳定性负责。同时，IT 操作员一定要在规划和开发阶段中包括治理、安全性和合规性。\n2. 缩短发布周期：DevOps 团队通过在短周期内发布软件保持敏捷。因为进度是渐进式的，缩短发布周期可以让计划和风险管理更容易，同时也可减少对系统稳定性的影响。缩短发布周期还可以让组织适应和应对不断变化的客户需求和竞争压力。\n3. 持续学习：高绩效的 DevOps 团队形成了一种成长思维。他们快速失败，然后将经验教训融入到他们的流程中，不断改进，提高客户满意度，加速创新和适应市场。DevOps 是一个旅程，所以总有成长的空间。\n\n### DevOps 做法\n\n除形成 DevOps 文化之外，团队还通过在整个应用程序生命周期中实施特定做法，以充分利用 DevOps。其中一些做法有助于加速、自动化和改进特定阶段。其他的跨越几个阶段，帮助团队创建可帮助提高生产效率的无缝进程。\n\n#### 持续集成和持续交付 (CI/CD)\n\n配置管理是指管理系统中资源（包括服务器、虚拟机和数据库）的状态。使用配置管理工具，团队能够以一种可控和系统的方式进行更改，因此降低了修改系统配置的风险。\n\n团队使用配置管理工具来跟踪系统状态并帮助避免配置漂移，即避免系统资源的配置随时间偏离为其定义的目标状态。\n\n通过与基础设施即代码结合使用，系统定义和配置都很容易进行模板化和自动化，帮助团队大规模地操作复杂的环境。\n\n\n#### 版本控制\n\n版本控制是管理各版本中代码的做法，用于跟踪修订和更改历史记录，使代码易于评审和恢复。通常使用版本控制系统来实现这种做法，这些系统允许多个开发人员协作编写代码。\n\n有关合并在相同文件中发生的代码更改、处理冲突以及将更改回滚到早期状态，这些系统具有一个清楚的流程。使用版本控制是一个基本的 DevOps 做法，可帮助开发团队协同工作，在团队成员之间划分编码任务，并存储所有代码，以便在需要时轻松恢复。版本控制也是其他做法（如持续集成和基础结构即代码）中的必要元素。\n\n#### 敏捷软件开发\n\n敏捷是一种软件开发方法，注重团队协作、客户和用户反馈，以及高度适应在短期发布周期内的变化。采用敏捷的团队向客户提供持续的更改和改进，收集他们的反馈，然后吸取经验并根据客户的需求和需要进行调整。敏捷与其他更传统的框架（如瀑布框架）有本质的不同，瀑布框架包括由顺序阶段定义的较长的发布周期。看板和 Scrum 是两种与敏捷相关的热门框架。\n\n#### 基础结构即代码\n\n基础结构即代码以一种描述性的方式定义系统资源和拓扑，团队可以像编码一样管理这些资源。这些定义也可以存储并在版本控制系统中进行版本控制以及像代码一样进行评审和还原。使用基础设施即代码有助于团队以可靠、可重复和可控的方式部署系统资源。基础设施即代码也有助于自动化部署并降低人为错误的风险，特别是对于复杂的大型环境。这种可重复、可靠的环境部署解决方案允许团队维护与生产环境相同的开发和测试环境。将环境复制到不同的数据中心和云平台同样变得更加简单和高效。\n\n配置管理：配置管理是指管理系统中资源（包括服务器、虚拟机和数据库）的状态。使用配置管理工具，团队能够以一种可控和系统的方式进行更改，因此降低了修改系统配置的风险。团队使用配置管理工具来跟踪系统状态并帮助避免配置漂移，即避免系统资源的配置随时间偏离为其定义的目标状态。\n\n\n#### 持续监视\n\n持续监视意味着能够全面、实时地了解整个应用程序堆栈（从运行应用程序的基础结构到更高级别的软件组件）的性能和运行状况。可查看的内容包括遥测和元数据集合，以及需要引起操作员注意的预定义条件警报的设置。遥测包括从系统各个部分收集的事件数据和日志，这些数据和日志存储在可以分析和查询的地方。高绩效的 DevOps 团队会确保他们设置了可操作且有意义的警报，并收集了丰富的遥测数据，以便能够从大量数据中获得见解。这些见解有助于团队实时解决问题，并了解如何在未来的开发周期中改进应用程序。通过与基础设施即代码结合使用，系统定义和配置都很容易进行模板化和自动化，帮助团队大规模地操作复杂的环境。\n\n\n### DevOps 的工作原理\n\n在 DevOps 模式下，开发团队和运营团队都不再是“孤立”的团队。 有时，这两个团队会合为一个团队，他们的工程师会在应用程序的整个生命周期（从开发测试到部署再到运营）内相互协作，开发出一系列不限于单一职能的技能。\n\n在一些 DevOps 模式下，质保和安全团队也会与开发和运营团队更紧密地结合在一起，贯穿应用程序的整个生命周期。当安全是所有 DevOps 团队成员的工作重心时，这有时被称为“DevSecOps”。\n\n这些团队会使用实践经验自动执行之前手动操作的缓慢流程。他们使用能够帮助其快速可靠地操作和发展应用程序的技术体系和工具。这些工具还可以帮助工程师独立完成通常需要其他团队协作才能完成的任务（例如部署代码或预置基础设施），从而进一步提高团队的工作速度。\n\n\n### DevOps 的优势\n\n* 速度：高速运转，让您可以更快速地针对客户进行创新、更好地适应不断变化的市场，同时更有效地推动业务成果。DevOps 模式能够帮助您的开发人员和运营团队实现这些目标。例如，微服务和持续交付能够让团队充分掌控服务，然后更快速地发布更新。\n* 快速交付：提高发布的频率和速度，以便您能够更快速地进行创新并完善产品。您发布新功能和修复错误的速度越快，就越能快速地响应客户需求并建立竞争优势。持续集成和持续交付是自动执行软件发布流程（从构建到部署）的两项实践经验。\n\n* 可靠性：确保应用程序更新和基础设施变更的品质，以便您能够在保持最终用户优质体验的同时，更加快速可靠地进行交付。使用持续集成和持续交付等实践经验来测试每次变更是否安全以及能够正常运行。监控和日志记录实践经验能够帮助您实时了解当前的性能。\n* 规模：大规模运行和管理您的基础设施及开发流程。自动化和一致性可在降低风险的同时，帮助您有效管理复杂或不断变化的系统。例如，基础设施即代码能够帮助您以一种可重复且更有效的方式来管理部署、测试和生产环境。\n\n* 增强合作：建立一个适应 DevOps 文化模式的更高效的团队，强调主人翁精神和责任感。开发人员和运营团队密切合作，共同承担诸多责任，并将各自的工作流程相互融合。这有助于减少效率低下的工作，同时节约大家的时间（例如，缩短开发人员和运营团队之间的交接时间，编写将运行环境考虑在内的代码）。\n* 安全性：在快速运转的同时保持控制力和合规性。利用自动实施的合规性策略、精细控制和配置管理技术，您可以在不牺牲安全性的前提下采用 DevOps 模式。例如，利用基础设施即代码和策略即代码，您可以大规模定义并追踪合规性。\n\n### DevOps 为什么很重要\n\n软件和 Internet 改变了我们身处的世界，同时也改变了购物、娱乐、银行等行业的运营方式。软件不再仅仅是为业务提供支持，而是成为业务的方方面面都不可或缺的组成部分。当前，公司通过采用在线服务或应用程序交付的软件，在各种设备上与客户进行互动。他们还使用软件改变了价值链的各个部分（例如物流、通信和运营），从而提高运营效率。在整个 20 世纪，生产实体产品的公司通过工业自动化改变了其设计、构建和交付产品的方式，而在当今的环境中，公司必须以同样的方式来改变其构建和交付软件的方式。\n","tags":["运维"],"categories":["知识碎片"]},{"title":"自动化构建","url":"/2024/10/08/自动化构建/","content":"#### 引言\n\n自动化构建是现代软件开发中不可或缺的一环。它可以大幅提高[开发流程](https://so.csdn.net/so/search?q=%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B&spm=1001.2101.3001.7020)的效率、减少人为错误，并确保交付高质量的软件。本文将深入探讨自动化构建的定义、作用、工作原理、常见工具和实际应用，以及如何利用自动化构建流程改进软件开发过程。\n\n#### 1. 什么是自动化构建\n\n##### 1.1 构建的概念\n\n构建是将源代码转换为可执行程序、库文件或部署包的过程，通常包括编译、打包、优化等步骤。\n\n##### 1.2 自动化构建的定义\n\n自动化构建是指通过使用脚本、工具或自动化流程来执行构建过程，而不需要手动干预，从而提高效率和可靠性。\n\n#### 2. 自动化构建的作用\n\n##### 2.1 自动化任务\n\n自动执行任务，如编译、压缩、测试和部署，减少了手动操作的繁琐性。\n\n##### 2.2 错误减少\n\n减少了人为错误的风险，确保每次构建都是一致的和可重复的。\n\n##### 2.3 高质量的交付\n\n通过自动化测试和部署，确保高质量的软件交付，减少了bug的数量。\n\n#### 3. 自动化构建的工作原理\n\n##### 3.1 构建工具\n\n使用构建工具，如Webpack、Grunt、Gulp等，定义构建任务和流程。\n\n##### 3.2 脚本\n\n编写自动化脚本，包括编译、打包、测试和部署等步骤。\n\n##### 3.3 集成\n\n将构建过程集成到[持续集成](https://cloud.tencent.com/product/coding-ci?from_column=20065&from=20065 \"持续集成\")（CI）工具中，如Jenkins、Travis CI等。\n\n#### 4. 常见的自动化构建任务\n\n##### 4.1 代码编译\n\n将源代码编译成可执行文件，如将JavaScript转换为浏览器可运行的代码。\n\n```bash\n// 示例：使用Babel编译ES6代码为ES5\nbabel src -d dist\n```\n\n##### 4.2 打包\n\n将多个文件或模块打包成一个文件，以减少网络请求。\n\n```bash\n// 示例：使用Webpack打包JavaScript和CSS文件\nwebpack --config webpack.config.js\n```\n\n##### 4.3 测试\n\n自动运行单元测试、集成测试，以及代码质量检查。\n\n```bash\n// 示例：运行Mocha单元测试\nmocha test/*.js\n```\n\n##### 4.4 部署\n\n将构建好的应用程序或服务部署到目标服务器。\n\n```bash\n# 示例：使用Docker部署容器化应用\ndocker build -t my-app .\ndocker run -p 8080:80 my-app\n```\n\n#### 5. 常用的自动化构建工具\n\n##### 5.1 Webpack\n\n用于JavaScript应用的模块打包工具，支持代码分割、加载器、插件等功能。\n\n```javascript\n// 部分webpack配置示例\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  // ...\n}\n```\n\n##### 5.2 Gulp\n\n自动化构建工具，使用流式操作来定义构建任务。\n\n```js\n// 示例：使用Gulp任务来压缩CSS文件\nconst gulp = require('gulp');\nconst minifyCSS = require('gulp-minify-css');\n \ngulp.task('minify-css', () => {\n  return gulp.src('src/*.css')\n    .pipe(minifyCSS())\n    .pipe(gulp.dest('dist'));\n});\n```\n\n##### 5.3 Jenkins\n\n开源的持续集成工具，支持自动化构建、测试和部署。\n\n#### 6. 自动化构建的实际应用\n\n##### 6.1 前端开发\n\n前端开发中使用Webpack等工具进行代码打包、压缩和优化，以提高性能。\n\n##### 6.2 后端开发\n\n自动化构建用于构建和部署服务器端应用程序，确保应用的稳定性。\n\n##### 6.3 移动应用\n\n在[移动应用开发](https://cloud.tencent.com/product/tcb?from_column=20065&from=20065 \"移动应用开发\")中，使用自动化构建来编译、打包和测试应用。\n\n#### 7. 自动化构建的未来趋势\n\n##### 7.1 容器化构建\n\n使用容器技术来执行构建任务，提高构建环境的可复制性。\n\n##### 7.2 自动化测试\n\n增加自动化测试的覆盖率，确保代码质量和可靠性。\n\n##### 7.3 DevOps集成\n\n将自动化构建与DevOps流程集成，实现持续交付和部署。\n\n#### 8. 结语\n\n自动化构建是现代软件开发的重要组成部分，它通过减少手动工作、减少错误和提高代码质量，提高了开发流程的效率和软件的质量。不论您是前端开发者、后端工程师还是移动应用程序开发人员，深入了解自动化构建的原理和工具都将对提高工作效率和软件交付产生积极影响。在不断演进的开发生态系统中，自动化构建将继续发展，为开发者提供更多的便利和支持。\n","tags":["运维"],"categories":["知识碎片"]},{"title":"Java内部类的应用分析","url":"/2024/10/08/Java内部类的应用分析/","content":"最近看了几篇博客，又温习了一次内部类相关的内容，感觉有必要在这方面写点博客记录一下，毕竟我个人接触的也不多，平时写代码也不常用，方便以后再次温习。\n\n啥是内部类呢，简单来说就是**写在类里面的类(Inner Class)**，也被叫做**嵌套类（Nested Class）**\n\n```java\nclass Outer {\n    class Inner {\n        // 定义了一个Inner Class\n    }\n}\n```\n\n具体的介绍可以看这里：[内部类 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://liaoxuefeng.com/books/java/oop/basic/inner-class/index.html \"内部类 - Java教程 - 廖雪峰的官方网站 (liaoxuefeng.com)\")，我在这里就不多赘述了。\n\n内部类是一个统称，具体的分类有哪些呢？\n\n![img](https://i-blog.csdnimg.cn/direct/a6afe705478f4e2ba9ab9c5bf83a31e4.png)\n\n### 内部类的主要应用\n\n* **访问外部类的私有成员** ，类似于写一个getter/setter方法，提供了一个外部管理私有字段的方法。我们来举个例子：\n\n  ```java\n  public class Outer {\n      private String outerField = \"Hello from Outer Class!\";\n\n      // 成员内部类\n      class Inner {\n          void displayOuterField() {\n              // 内部类访问外部类的私有成员\n              System.out.println(outerField);\n          }\n      }\n\n      // 创建内部类的实例并调用其方法\n      void createInner() {\n          Inner inner = new Inner();\n          inner.displayOuterField();\n      }\n\n      public static void main(String[] args) {\n          Outer outer = new Outer();\n          outer.createInner();  // 调用外部类的方法\n      }\n  }\n  ```\n* **封装代码** ，从第一条就能看出来。\n* **简化代码结构** ，例如想要手动实现一个表，那么这个表的数据结构肯定会占很大篇幅，这时候不妨把代码放到内部类，和其他逻辑区分开。比如我们来写一个图的结构：\n\n  ```java\n  import java.util.ArrayList;\n  import java.util.List;\n\n  public class Graph {\n      // 内部类表示图的顶点\n      class Vertex {\n          String name;\n          List<Vertex> adjacentVertices;\n\n          // 构造函数\n          Vertex(String name) {\n              this.name = name;\n              this.adjacentVertices = new ArrayList<>();\n          }\n\n          // 添加邻接顶点\n          void addAdjacent(Vertex vertex) {\n              adjacentVertices.add(vertex);\n          }\n\n          // 打印顶点及其邻接顶点\n          void display() {\n              System.out.print(\"Vertex: \" + name + \" is connected to: \");\n              for (Vertex v : adjacentVertices) {\n                  System.out.print(v.name + \" \");\n              }\n              System.out.println();\n          }\n      }\n\n      private List<Vertex> vertices;\n\n      // 构造函数\n      public Graph() {\n          this.vertices = new ArrayList<>();\n      }\n\n      // 添加顶点\n      public Vertex addVertex(String name) {\n          Vertex vertex = new Vertex(name);\n          vertices.add(vertex);\n          return vertex;\n      }\n\n      // 打印所有顶点\n      public void displayGraph() {\n          for (Vertex vertex : vertices) {\n              vertex.display();\n          }\n      }\n\n      public static void main(String[] args) {\n          Graph graph = new Graph();\n          Graph.Vertex v1 = graph.addVertex(\"A\");\n          Graph.Vertex v2 = graph.addVertex(\"B\");\n          Graph.Vertex v3 = graph.addVertex(\"C\");\n\n          // 添加邻接关系\n          v1.addAdjacent(v2);\n          v1.addAdjacent(v3);\n          v2.addAdjacent(v3);\n\n          // 打印图的信息\n          graph.displayGraph();\n      }\n  }\n  ```\n\n**处理监听事件** ，这个和c#的事件委托机制很像，例如有了内部类，可以把所有鼠标点击回调的逻辑放到一个内部类里，以后需要添加或修改鼠标点击的逻辑的时候，只需要修改这个内部类就可以了\n举个例子：\n\n```java\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\n \npublic class ButtonExample {\n    private String buttonLabel = \"Click me!\";\n \n    public ButtonExample() {\n        JFrame frame = new JFrame();\n        JButton button = new JButton(buttonLabel);\n \n        // 成员内部类作为事件监听器\n        button.addActionListener(new ButtonClickListener());\n \n        frame.add(button);\n        frame.setSize(200, 200);\n        frame.setVisible(true);\n    }\n \n    // 内部类\n    class ButtonClickListener implements java.awt.event.ActionListener {\n        public void actionPerformed(java.awt.event.ActionEvent e) {\n            System.out.println(\"Button clicked! Label: \" + buttonLabel);\n        }\n    }\n \n    public static void main(String[] args) {\n        new ButtonExample();\n    }\n}\n```\n\n**实现接口，或者多重继承** ，我们不想让外部访问到我们的实现方式，只需要在私有的内部类里面写接口的实现即可。\n\n```java\n// 定义接口\ninterface Animal {\n    void makeSound();  // 声明一个抽象方法\n}\n \n// 外部类\npublic class AnimalShelter {\n  \n    // 成员内部类 Dog\n    private class Dog implements Animal {\n        @Override\n        public void makeSound() {\n            System.out.println(\"Woof!\");  // 实现狗叫声\n        }\n    }\n \n    // 成员内部类 Cat\n    private class Cat implements Animal {\n        @Override\n        public void makeSound() {\n            System.out.println(\"Meow!\");  // 实现猫叫声\n        }\n    }\n \n    // 方法来创建并使用内部类\n    public void adoptAnimals() {\n        Animal dog = new Dog();  // 创建 Dog 对象\n        Animal cat = new Cat();   // 创建 Cat 对象\n \n        dog.makeSound();  // 调用 Dog 的方法\n        cat.makeSound();  // 调用 Cat 的方法\n    }\n \n    public static void main(String[] args) {\n        AnimalShelter shelter = new AnimalShelter(); // 创建 AnimalShelter 对象\n        shelter.adoptAnimals(); // 调用 adoptAnimals 方法\n    }\n}\n```\n\n至于 **静态内部类** ，大多是在**设计模式**中应用，例如实现工厂模式中的工厂类：\n\n```java\npublic class Outer {\n    private static int count = 0;\n \n    // 静态内部类\n    static class Inner {\n        private int id;\n \n        Inner() {\n            this.id = ++count;  // 为每个内部类实例分配一个唯一 ID\n        }\n \n        public int getId() {\n            return id;\n        }\n    }\n \n    public static void main(String[] args) {\n        Inner inner1 = new Inner();\n        Inner inner2 = new Inner();\n \n        System.out.println(\"Inner 1 ID: \" + inner1.getId());  // 输出：Inner 1 ID: 1\n        System.out.println(\"Inner 2 ID: \" + inner2.getId());  // 输出：Inner 2 ID: 2\n    }\n}\n```\n\n方法内部类我用的较少，但是还是举个例子，这是用 **局部内部类（方法内部类）进行临时算法的封装** ：\n\n```java\npublic class Calculator {\n  \n    public double calculate(int base, int exponent) {\n    \n        // 局部静态类用于计算幂\n        class PowerCalculator {\n            double calculatePower() {\n                return Math.pow(base, exponent);\n            }\n        }\n    \n        PowerCalculator powerCalculator = new PowerCalculator();\n        return powerCalculator.calculatePower();  // 调用局部静态类的方法\n    }\n \n    public static void main(String[] args) {\n        Calculator calculator = new Calculator();\n        double result = calculator.calculate(2, 3);  // 2的3次方\n        System.out.println(\"Result: \" + result);  // 输出：Result: 8.0\n    }\n}\n```\n\n匿名内部类比较特殊，不需要变量名，创建时自带一个生命周期，在生命周期内自动被调用，也就是说，匿名内部类一般和其他的类或者方法是绑定在一起的，由其他的类或方法来控制其行为。它的应用大概有这些：\n\n* **事件处理** ，这里先给出一个例子\n\n  ```java\n  import javax.swing.JButton;\n  import javax.swing.JFrame;\n\n  public class ButtonExample {\n      public static void main(String[] args) {\n          JFrame frame = new JFrame(\"Button Example\");\n          JButton button = new JButton(\"Click me!\");\n\n          // 使用匿名内部类实现 ActionListener\n          button.addActionListener(new java.awt.event.ActionListener() {\n              @Override\n              public void actionPerformed(java.awt.event.ActionEvent e) {\n                  System.out.println(\"Button clicked!\");\n              }\n          });\n\n          frame.add(button);\n          frame.setSize(200, 200);\n          frame.setVisible(true);\n          frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n      }\n  }\n  ```\n\n这里和C#的事件委托机制是一样的，只是java有些区别罢了，创建的事件类并没有一个确切的名字，它单纯是和我们的buttonclick绑定在了一起，每次这个按钮被点击，就会激活这个事件，但是具体这个事件较什么名字我们并不清楚，只知道要让这个事件去做一些事，调一些函数。\n\n* **代码简化**\n\n  ```java\n  public class AnimalExample {\n      public static void main(String[] args) {\n          // 使用匿名内部类实现接口\n          Animal dog = new Animal() {\n              @Override\n              public void makeSound() {\n                  System.out.println(\"Woof!\");\n              }\n          };\n\n          dog.makeSound();  // 输出：Woof!\n      }\n  }\n  ```\n* **实现比较器** ，集合排序的时候是需要一个比较器的，也就是我们排序需要一个规则，这和数据库的理论很像，这个时候我们可以用匿名内部类来实现Comparator接口：\n\n  ```java\n  import java.util.Arrays;\n  import java.util.Comparator;\n\n  public class SortExample {\n      public static void main(String[] args) {\n          String[] names = {\"Alice\", \"Bob\", \"Charlie\"};\n\n          // 使用匿名内部类实现Comparator\n          Arrays.sort(names, new Comparator<String>() {\n              @Override\n              public int compare(String s1, String s2) {\n                  return s1.length() - s2.length();  // 按字符串长度排序\n              }\n          });\n\n          System.out.println(Arrays.toString(names));  // 输出：[Bob, Alice, Charlie]\n      }\n  }\n  ```\n","tags":["编程语言"]},{"title":"聊聊Vue的diff算法","url":"/2024/10/08/聊聊Vue的diff算法/","content":"相比大家早早听说过了虚拟DOM的存在，Diff算法的运用是虚拟DOM具有高性能的一个重要原因。\n\n# 虚拟DOM\n\nVue的虚拟DOM实质上就是生成一个AST（抽象语法树Abstract Syntax Tree）\n![1728368888139](../pic/1728368888139.png)\n\n我们可以用这一串代码来看看原生DOM有多复杂：\n\n```javascript\nlet div = document.createElement('div')\nlet str = ''\nfor (const key in div) {\n  str += key + ''\n}\nconsole.log(str)\n```\n\n解决方案就是 我们可以用 `JS`的计算性能来换取操作 `DOM`所消耗的性能，既然我们逃不掉操作 `DOM`这道坎,但是我们可以尽可能少的操作 `DOM`，这时候就是Diff算法发挥的时候了\n\n# Diff算法\n\nDiff 算法，在 Vue 里面就是叫做 `patch` ，它的核心就是参考 [Snabbdom](https://link.segmentfault.com/?enc=H3aijtI%2BxaIigBqfxKP0lA%3D%3D.ca891itMtRaYyNev4FcPITuKvIoV%2Fno7aV1ewicTT37iG8nGdEFMLHFgoOLp%2Bewu)，通过新旧虚拟 DOM 对比(即 patch 过程)，找出最小变化的地方转为进行 DOM 操作\n\n> 在 Vue1 里是没有 patch 的，每个依赖都有单独的 Watcher 负责更新，当项目规模变大的时候性能就跟不上了，所以在 Vue2 里为了提升性能，改为每个组件只有一个Watcher，那我们需要更新的时候，怎么才能精确找到组件里发生变化的位置呢？所以 patch 它来了\n\n![comp](https://segmentfault.com/img/remote/1460000040808699/view)\n\n比如有上图这样的 DOM 结构，是怎么计算出变化？简单说就是\n\n* 遍历老的虚拟 DOM\n* 遍历新的虚拟 DOM\n* 然后根据变化，比如上面的改变和新增，再重新排序\n\n可是这样会有很大问题，假如有1000个节点，就需要计算 1000³ 次，也就是10亿次，这样是无法让人接受的，所以 Vue 或者 React 里使用 Diff 算法的时候都遵循深度优先，同层比较的策略做了一些优化，来计算出**最小变化**\n\n# Diff算法怎么优化？\n\n**1. 只比较同一层级，不跨级比较**\n\n如图，Diff 过程只会把同颜色框起来的同一层级的 DOM 进行比较，这样来简化比较次数，这是第一个方面\n\n![img](https://segmentfault.com/img/remote/1460000040808700)\n\n**2. 比较标签名**\n\n如果同一层级的比较标签名不同，就直接移除老的虚拟 DOM 对应的节点，不继续按这个树状结构做深度比较，这是简化比较次数的第二个方面\n\n**3. 比较 key**\n\n如果标签名相同，key 也相同，就会认为是相同节点，也不继续按这个树状结构做深度比较，比如我们写 v-for 的时候会比较 key，不写 key 就会报错，这也就是因为 Diff 算法需要比较 key\n\n面试中有一道特别常见的题，就是让你说一下 key 的作用，实际上考查的就是大家对虚拟 DOM 和 patch 细节的掌握程度，能够反应出我们面试者的理解层次，所以这里扩展一下 key\n\n# Key的作用\n\n![img](https://i-blog.csdnimg.cn/blog_migrate/4f04f49d4c37e2c78b0849ee2fd620a1.png)\n\n**在Vue源码的renderer.ts的1600行左右：**\n\n```javascript\n\nconst patchUnkeyedChildren = (\n    c1: VNode[],\n    c2: VNodeArrayChildren,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    namespace: ElementNamespace,\n    slotScopeIds: string[] | null,\n    optimized: boolean,\n  ) => {\n    c1 = c1 || EMPTY_ARR\n    c2 = c2 || EMPTY_ARR\n    const oldLength = c1.length\n    const newLength = c2.length\n    const commonLength = Math.min(oldLength, newLength)\n    let i\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = (c2[i] = optimized\n        ? cloneIfMounted(c2[i] as VNode)\n        : normalizeVNode(c2[i]))\n      patch(\n        c1[i],\n        nextChild,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n      )\n    }\n    if (oldLength > newLength) {\n      // remove old\n      unmountChildren(\n        c1,\n        parentComponent,\n        parentSuspense,\n        true,\n        false,\n        commonLength,\n      )\n    } else {\n      // mount new\n      mountChildren(\n        c2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n        commonLength,\n      )\n    }\n  }\n```\n\n对于没有key的patch更新是这样的，也就是简单的去头去尾之后来更新\n\n而对于有key的更新：\n\n```javascript\nconst patchKeyedChildren = (\n    c1: VNode[],\n    c2: VNodeArrayChildren,\n    container: RendererElement,\n    parentAnchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    namespace: ElementNamespace,\n    slotScopeIds: string[] | null,\n    optimized: boolean,\n  ) => {\n    let i = 0\n    const l2 = c2.length\n    let e1 = c1.length - 1 // prev ending index\n    let e2 = l2 - 1 // next ending index\n\n    // 1. sync from start\n    // (a b) c\n    // (a b) d e\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i]\n      const n2 = (c2[i] = optimized\n        ? cloneIfMounted(c2[i] as VNode)\n        : normalizeVNode(c2[i]))\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized,\n        )\n      } else {\n        break\n      }\n      i++\n    }\n\n    // 2. sync from end\n    // a (b c)\n    // d e (b c)\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1]\n      const n2 = (c2[e2] = optimized\n        ? cloneIfMounted(c2[e2] as VNode)\n        : normalizeVNode(c2[e2]))\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized,\n        )\n      } else {\n        break\n      }\n      e1--\n      e2--\n    }\n\n    // 3. common sequence + mount\n    // (a b)\n    // (a b) c\n    // i = 2, e1 = 1, e2 = 2\n    // (a b)\n    // c (a b)\n    // i = 0, e1 = -1, e2 = 0\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1\n        const anchor = nextPos < l2 ? (c2[nextPos] as VNode).el : parentAnchor\n        while (i <= e2) {\n          patch(\n            null,\n            (c2[i] = optimized\n              ? cloneIfMounted(c2[i] as VNode)\n              : normalizeVNode(c2[i])),\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n          )\n          i++\n        }\n      }\n    }\n\n    // 4. common sequence + unmount\n    // (a b) c\n    // (a b)\n    // i = 2, e1 = 2, e2 = 1\n    // a (b c)\n    // (b c)\n    // i = 0, e1 = 0, e2 = -1\n    else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true)\n        i++\n      }\n    }\n\n    // 5. unknown sequence\n    // [i ... e1 + 1]: a b [c d e] f g\n    // [i ... e2 + 1]: a b [e d c h] f g\n    // i = 2, e1 = 4, e2 = 5\n    else {\n      const s1 = i // prev starting index\n      const s2 = i // next starting index\n\n      // 5.1 build key:index map for newChildren\n      const keyToNewIndexMap: Map<PropertyKey, number> = new Map()\n      for (i = s2; i <= e2; i++) {\n        const nextChild = (c2[i] = optimized\n          ? cloneIfMounted(c2[i] as VNode)\n          : normalizeVNode(c2[i]))\n        if (nextChild.key != null) {\n          if (__DEV__ && keyToNewIndexMap.has(nextChild.key)) {\n            warn(\n              `Duplicate keys found during update:`,\n              JSON.stringify(nextChild.key),\n              `Make sure keys are unique.`,\n            )\n          }\n          keyToNewIndexMap.set(nextChild.key, i)\n        }\n      }\n\n      // 5.2 loop through old children left to be patched and try to patch\n      // matching nodes & remove nodes that are no longer present\n      let j\n      let patched = 0\n      const toBePatched = e2 - s2 + 1\n      let moved = false\n      // used to track whether any node has moved\n      let maxNewIndexSoFar = 0\n      // works as Map<newIndex, oldIndex>\n      // Note that oldIndex is offset by +1\n      // and oldIndex = 0 is a special value indicating the new node has\n      // no corresponding old node.\n      // used for determining longest stable subsequence\n      const newIndexToOldIndexMap = new Array(toBePatched)\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0\n\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i]\n        if (patched >= toBePatched) {\n          // all new children have been patched so this can only be a removal\n          unmount(prevChild, parentComponent, parentSuspense, true)\n          continue\n        }\n        let newIndex\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key)\n        } else {\n          // key-less node, try to locate a key-less node of the same type\n          for (j = s2; j <= e2; j++) {\n            if (\n              newIndexToOldIndexMap[j - s2] === 0 &&\n              isSameVNodeType(prevChild, c2[j] as VNode)\n            ) {\n              newIndex = j\n              break\n            }\n          }\n        }\n        if (newIndex === undefined) {\n          unmount(prevChild, parentComponent, parentSuspense, true)\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex\n          } else {\n            moved = true\n          }\n          patch(\n            prevChild,\n            c2[newIndex] as VNode,\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n          )\n          patched++\n        }\n      }\n\n      // 5.3 move and mount\n      // generate longest stable subsequence only when nodes have moved\n      const increasingNewIndexSequence = moved\n        ? getSequence(newIndexToOldIndexMap)\n        : EMPTY_ARR\n      j = increasingNewIndexSequence.length - 1\n      // looping backwards so that we can use last patched node as anchor\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i\n        const nextChild = c2[nextIndex] as VNode\n        const anchor =\n          nextIndex + 1 < l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor\n        if (newIndexToOldIndexMap[i] === 0) {\n          // mount new\n          patch(\n            null,\n            nextChild,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n          )\n        } else if (moved) {\n          // move if:\n          // There is no stable subsequence (e.g. a reverse)\n          // OR current node is not among the stable sequence\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, MoveType.REORDER)\n          } else {\n            j--\n          }\n        }\n      }\n    }\n  }\n```\n\n首先经过去头去尾留下中间部分，然后找出最长递增子序列，在此序列基础上进行增删改来更新，节省了大量性能\n\n鱿鱼须在这里也留下了他的源码：\n\n```javascript\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction getSequence(arr: number[]): number[] {\n  const p = arr.slice()\n  const result = [0]\n  let i, j, u, v, c\n  const len = arr.length\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i]\n    if (arrI !== 0) {\n      j = result[result.length - 1]\n      if (arr[j] < arrI) {\n        p[i] = j\n        result.push(i)\n        continue\n      }\n      u = 0\n      v = result.length - 1\n      while (u < v) {\n        c = (u + v) >> 1\n        if (arr[result[c]] < arrI) {\n          u = c + 1\n        } else {\n          v = c\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1]\n        }\n        result[u] = i\n      }\n    }\n  }\n  u = result.length\n  v = result[u - 1]\n  while (u-- > 0) {\n    result[u] = v\n    v = p[v]\n  }\n  return result\n}\n```\n\n看到这里不禁惊叹，大佬就是大佬，我们平时刷的累死的leetcode题目，大佬信手拈来搞优化，真是隔行如隔山。\n","tags":["前端"]},{"title":"Vue重学计划（二）","url":"/2024/10/07/Vue重学计划（二）/","content":"第二期，我们从比较~~基础~~的部分入手，来做一个深入的认知\n\n# Nodejs的源码结构\n\n提到基础，就不得不说这个伟大的Nodejs了，为啥说它伟大呢？\n\n> **在JavaScript语言努力摆脱“玩具语言”这个标签的进化历程中，Node.js绝对能记下浓墨重彩的一笔。** Node.js并不是一个用于实现具体功能的第三方工具库，而是JavaScript程序的运行环境。\n\n在Node.js出现之前，使用JavaScript语言编写的脚本需要在网页中被 `<script>`标签引用后才能执行，这就使得前端开发人员编写的程序无论怎么看都像是界面的一种附属品。 **而Node.js的出现打破了这个枷锁** ，它提供的运行时能够让JavaScript程序在桌面、命令行终端、手机、平板电脑甚至**嵌入式系统**上运行，这不仅极大地丰富了JavaScript的应用场景，也为后来的前端工程化发展和中间层架构模型的兴起奠定了基础。\n\n## Nodejs是什么？\n\n> Node.js是一个基于Chrome V8引擎的JavaScript运行环境。Node.js使用了一个事件驱动的、非阻塞式I/O的模型，轻量又高效，它的底层是用C/C++编写的。这是Node.js的官方描述，对前端开发人员来说，想要搞清楚其中所包含的“引擎”“运行环境”“事件驱动”以及“非阻塞I/O模型”到底是什么意思，并不是一件容易的事情。\n\n要理解这段话和它背后的真正力量，我们需要把 Node.js 拆分到组件，了解它们的关键技术，如何交互协作，最终构成了 Node.js 这个强大的运行时环境：\n\n![1728313069799](Vue重学计划（二）/1728313069799.png)\n\n它们是这样分工的：\n\n[**V8**](https://link.segmentfault.com/?enc=MWhl%2F932Qfdc%2Fd2nsfxM1w%3D%3D.NpNMHIW68G85VeQTb2pVJYVR%2B76WIEx4lEh2iauvIsrUz%2B%2FQFq16aEfCNhrue2eu)：Google 开源的高性能 JavaScript 引擎，以 C++ 实现。这也是集成在 Chrome 中的 JS 引擎。V8 将你写的 JavaScript 代码编译为机器码（所以它超级快）然后执行。V8 有多快？看看[这个爆栈网的回答](https://link.segmentfault.com/?enc=85Hko9%2BRFa%2FPHvH6byDwBg%3D%3D.cvVPo%2Fvph0VGeFW2VswA%2BLxNCktK7Rs69h3hS0IjKjzHa7xF%2BRQ2u1dxAgOXmxC2)。\n\n[**libuv**](https://link.segmentfault.com/?enc=slfyaTN7z1%2BCOe%2ByH761uA%3D%3D.WOb9nQmmJohdgx6Sj2%2BLjedEKBU%2BKTZqdgaxqcdjcKc%3D)：提供异步功能的 C 库。它在运行时负责一个事件循环（Event Loop）、一个线程池、文件系统 I/O、DNS 相关和网络 I/O，以及一些其他重要功能。\n\n[**其他 C/C++ 组件和库**](https://link.segmentfault.com/?enc=0kBZVWiXq2aOlCa2R4T2Tg%3D%3D.ky0ULR0KXFBIyFMKIQLnkfFTMPcH6si7zNLwBBml15NTXk94ayOUxHV2TAZiiv8Q3ZDrF2NsFdlAnRw%2FKuIThQ%3D%3D)：如 [c-ares](https://link.segmentfault.com/?enc=ljzvhrP4oxpKXqGuB%2FMTjw%3D%3D.H%2BP8XnrlZDjyC6sXDHad1ZFmHLFY5QwnrzTo7VqIYEU%3D)、[crypto (OpenSSL)](https://link.segmentfault.com/?enc=sLZtgHX0oRJ1mjoA3g31Hw%3D%3D.%2B%2FrNH9%2FqMc1MEj5sYCc3awBrN0yDxe8rrFUMJsGdHjM%3D)、[http-parser](https://link.segmentfault.com/?enc=wFIzBKRhoLqtd9Wy8NbsNQ%3D%3D.B5uJaDqo%2BF29QTGd3xRroOEm5kD2rEHnA4IfrVypsjt9jjWQ%2FqCbOs8j8M59bqUN) 以及 [zlib](https://link.segmentfault.com/?enc=jh8FDMyJypJAtJdXiD5iWQ%3D%3D.A5hQTM%2FGaw5zRWE1dJQntOYG9A%2BNCTkCPz1W2YfPzSc%3D)。这些依赖提供了对系统底层功能的访问，包括网络、压缩、加密等。\n\n## 架构方面的热门讨论\n\n在Stack Overflow上，关于这个架构有一个热门的讨论[javascript - Which is correct Node.js architecture? - Stack Overflow](https://stackoverflow.com/questions/36766696/which-is-correct-node-js-architecture/37512766#37512766)\n\nAren Li是这么认为的：\n\n![1728313120917](Vue重学计划（二）/1728313120917.png)\n\n原文在此：[Architecture of Node.js’ Internal Codebase | by Aren Yanqi Li | Yet Another Node.js Blog | Medium](https://medium.com/yet-another-node-js-blog/architecture-of-node-js-internal-codebase-57cd8376b71f)\n\n# Vite项目架构重点解读\n\n## 源码类文件\n\npublic 下面的不会被编译 可以存放静态资源\n\nassets 下面可以存放可编译的静态资源\n\ncomponents 下面用来存放我们的组件\n\nApp.vue 是全局组件\n\nmain.ts 是全局的ts文件\n\n**index.html 一个有意思的入口文件**\n\n为什么说index.html是一个有意思的文件？用过纯Vue或者Vue-cli生成项目的朋友应该发现了，只有Vite生成的项目里面是自带这个html入口的\n\nVite文档给出了解答：\n\n> 您可能已经注意到，在 Vite 项目中，`index.html` 是核心，而不是隐藏在 `public` 中。这是有意的：在开发过程中，Vite 是一个服务器，而 `index.html` 是您应用程序的入口点。\n>\n> Vite 将 `index.html` 视为源代码和模块图的一部分。它解析引用您的 JavaScript 源代码的 `<script type=\"module\" src=\"...\">`。即使是内联 `<script type=\"module\">` 和通过 `<link href>` 引用的 CSS 也能享受 Vite 特定的功能。此外，`index.html` 中的 URL 会自动重新定位，因此不需要特殊的 `%PUBLIC_URL%` 占位符。\n>\n> 与静态 http 服务器类似，Vite 有一个“根目录”的概念，您的文件将从该目录提供服务。您将在本文档的其余部分中看到它被引用为 `<root>`。您源代码中的绝对 URL 将使用项目根目录作为基准进行解析，因此您可以像使用普通的静态文件服务器一样编写代码（但功能更强大！）。Vite 还能够处理解析到根目录之外的文件系统位置的依赖项，这使得它即使在基于单仓库的设置中也能使用。\n>\n> Vite 还支持具有多个 `.html` 入口点的 [多页面应用程序](https://vite.vuejs.ac.cn/guide/build#multi-page-app)。\n\n事实上，**webpack，rollup 他们的入口文件都是enrty input 是一个js文件 而Vite 的入口文件是一个html文件，他刚开始不会编译这些js文件 只有当你用到的时候 如script src=\"xxxxx.js\" 会发起一个请求被vite拦截这时候才会解析js文件**\n\n## 配置类文件\n\nvite config ts 等等后面再说。\n\n# npm run dev 指令\n\n**npm run dev** 指令会再package.json中被解析成**vite**这个指令，这个vite其实就是启动vite 服务器的指令。\n\n那为什么我们不直接执行vite 命令不是更方便吗？\n\n这是因为在我们的电脑上面并没有配置过相关命令 所以无法直接执行,不信你可以在你的项目中输入vite，正常情况应该都不能执行，可以执行的都是自行配置过的\n\n 其实在我们执行npm install 的时候（包含vite） 会在node_modules/.bin/ 创建好可执行文件\n\n.bin 目录，这个目录不是任何一个 npm 包。目录下的文件，表示这是一个个软链接，打开文件可以看到文件顶部写着 #!/bin/sh ，表示这是一个脚本\n\n在我们执行npm run xxx  npm 会通过软连接 查找这个软连接存在于源码目录node_modules/vite\n\n所以npm run xxx 的时候，就会到 node_modules/bin中找对应的映射文件，然后再找到相应的js文件来执行\n\n1.查找规则是先从当前项目的node_modlue /bin去找,\n\n2.找不到去全局的node_module/bin 去找\n\n3.再找不到 去环境变量去找\n\n至于node_modules/.bin中的三个文件：\n\n```bash\n# unix Linux macOS 系默认的可执行文件，必须输入完整文件名\nvite\n \n# windows cmd 中默认的可执行文件，当我们不添加后缀名时，自动根据 pathext 查找文件\nvite.cmd\n \n# Windows PowerShell 中可执行文件，可以跨平台\nvite.psl\n```\n\n我们使用**windows** 一般执行的是第二个，而MacOS Linux 一般是第一个。\n\n详情可以参考：[学习Vue3 第三章（Vite目录 &amp; Vue单文件组件 &amp; npm run dev 详解）_npm run dev vite-CSDN博客](https://xiaoman.blog.csdn.net/article/details/122771007)\n\n# 比较罕见的几个vue模板指令\n\n> Vue指令大全：\n>\n> v- 开头都是vue 的指令\n>\n> v-text 用来显示文本\n>\n> v-html 用来展示富文本\n>\n> v-if 用来控制元素的显示隐藏（切换真假DOM）\n>\n> v-else-if 表示 v-if 的“else if 块”。可以链式调用\n>\n> v-else v-if条件收尾语句\n>\n> v-show 用来控制元素的显示隐藏（display none block Css切换）\n>\n> v-on 简写@ 用来给元素添加事件\n>\n> v-bind 简写:  用来绑定元素的属性Attr\n>\n> v-model 双向绑定\n>\n> v-for 用来遍历元素\n>\n> v-on修饰符(.stop/.once等等) 用于冒泡相关操作\n>\n> v-once 性能优化，只渲染一次\n>\n> v-memo 性能优化，会有缓存\n\n这里面，基本上没怎么用过的是v-once和v-memo，可以参考这篇文章：[Vue3.2 新增 v-memo](https://juejin.cn/post/7180973915580137527)\n\n后面有机会也要自己试试嘞！\n","tags":["前端"],"categories":["Vue3重学计划"]},{"title":"TreeShaking技术泛谈","url":"/2024/10/06/TreeShaking技术泛谈/","content":"# 发源\n\nTree-shaking 这一术语在前端社区内，起初是 [Rich Harris](https://link.segmentfault.com/?enc=a9sEtaJrGvQZLMaXxUSlXQ%3D%3D.iGjYfWsubiyid367c3gVzcd57dVW35aQSB0Bz5u5wZI%3D \"Rich Harris\") 在 Rollup 中提出。简单概括起来，Tree-shaking 可以使得项目最终构建（Bundle）结果中只包含你实际需要的代码。\n\n![1728313255298](TreeShaking技术泛谈/1728313255298.png)\n\n而且，说到 Tree-shaking，不难免提及 Dead Code Elimination，相信很多同学在一些关于 Tree-shaking 的文章中都会看到诸如这样的描述：Tree-shaking 是一项 Dead Code Elimination（以下统称 DCE）技术。\n\n那么，既然有了 DCE 这一术语，为什么又要造一个 Tree-shaking 术语？存在既有价值，下面，让我们一起来看看 Rich Harris 是如何回答这个问题的\n\n# 1. DCE vs. Tree-Shaking\n\n在当时 Rich Haris 针对这一提问专门写了这篇文章[《Tree-shaking versus dead code elimination》](https://link.segmentfault.com/?enc=Vlfq3PO2dcK%2FNJzTbd%2Fa7w%3D%3D.wxtSXtOWIByS4OQ4lowXE2PH8cml%2FPzyV3WWck18zT9rTwLg8EejE%2BQAWFkLGwzqc3ImYA9Y%2BvTUH7fELHwbugFRGeLbv4BC47Tbowb24rsHctDa6S9ibe1KlWlzMKaU \"《Tree-shaking versus dead code elimination》\")，文中表示 DCE 和 Tree-shaking 最终的目标是一致的（更少的代码），但是它们仍然是存在区别的。\n\nRich Haris 举了个做蛋糕的例子，指出 DCE 就好比在做蛋糕的时候直接把鸡蛋放入搅拌，最后在做好的蛋糕中取出蛋壳，这是不完美的做法，而 Tree-shaking 则是在做蛋糕的时候只放入我想要的东西，即不会把蛋壳放入搅拌制作蛋糕。\n\n因此，Tree-shaking 表达的不是指消除 Dead Code，而是指保留 Live Code。即使最终 DCE 和 Tree-shaking 的结果是一致的，但是由于 JavaScript 静态分析的局限性，实际过程并不同。并且，包含有用的代码可以得到更好的结果，从表面看（做蛋糕的例子）这也是一种更符合逻辑的方法。\n\n此外，当时 Rich Haris 也认为 Tree-shaking 可能不是一个很好的名称，考虑过用 Live Code Inclusion 这个短语来表示，但是似乎会造成更多的困惑......让我们看一下 Rich Haris 的原话：\n\n> I thought about using the ‘live code inclusion’ phrase with Rollup, but it seemed that I’d just be adding even more confusion seeing as tree-shaking is an existing concept. Maybe that was the wrong decision?\n\n所以，我想到这里同学们应该清楚一点，Tree-shaking 和 DCE 只是最终的结果 **是一致的** ，但是 2 者 **实现的过程不同** ，Tree-shaking 是保留 Live Code，而 DCE 是消除 Dead Code。\n\n并且，当时 Rich Harris 也指出 Rollup 也不是完美的，最好的结果是使用 Rollup + Uglify 的方式。不过，显然现在的 Rollup `v2.55.1` 已经臻至完美。那么，接下来让我们沿着时间线看看 Tree-shaking 的演变\n\n# 2.Tree-Shaking的演化\n\nTree-shaking  **在最初被提出的时候它只会做一件事** ，那就是利用 ES Module 静态导入的特点来检测模块内容的导出、导入以及被使用的情况，从而实现保留 Live Code 的目的。\n\n也许这个时候你会问 Tree-shaking 不是还会消除 Dead Code 吗？确实，但是也不一定，如果你使用的是现在的 Rollup `v2.55.1`，它是会进行 DCE，即消除 Dead Code。但是，如果你用的是 Webpack 的话，那就是另一番情况了，它需要使用 Uglify 对应的插件来实现 DCE。\n\n下面，我们以 Rollup 为例，聊聊过去和现在的 Tree-shaking。\n\n### 2.1过去的 Tree-shaking\n\n在早期， Rollup 提出和支持 Tree-shaking 的时候，它并不会做额外的 DCE，这也可以在 15 年 Rich Haris 写的那篇文章中看出，当时他也提倡大家使用 Rollup + Uglify。所以，这里让我们一起把**时间倒回** Rollup `v0.10.0` 的 Tree-shaking。\n\n回到 Rollup `v0.10.0` 版本，你会发现非常有趣的一点，就是它的 GitHub README 介绍是这样的：\n\n![1728313265262](TreeShaking技术泛谈/1728313265262.png)\n\nRollup 的命名来源于一首名为《Roll up》的说唱歌曲，我想这应该出乎了很多同学的意料。不过话说 Evan You 也喜欢说唱，然后我（你）也喜欢说唱，所以这也许可以论证我（你）选择前端似乎没错？这里附上这首歌，你可以选择听这首歌来拉近 Rollup 的距离。\n\n> 传送门：[https://www.youtube.com/watch...](https://link.segmentfault.com/?enc=fq6Q%2BXC%2B%2FUwjejTNfN6YbQ%3D%3D.CFK9bUF4j6I2V6mZzFW1brk7xofDUyNFlAuHxIPwr%2F1psgQNEMZ765uhLFbJM1eS)\n\n下面，我们使用 Rollup `v0.10.0` 版本来做一个简单示例来验证一下前面说的。并且，在这个过程中需要注意，如果你的 Node 版本过高会导致一些不兼容，所以建议用 Node `v11.15.0` 来运行下面的例子。\n\n首先，初始化项目和安装基础的依赖：\n\n```\nnpm init -y\nnpm i rollup@0.10.0 -D\n```\n\n然后，分别新建 3 个文件：\n\nutils.js\n\n```\nexport const foo = function () {\n  console.log(\"foo\");\n};\n\nexport const bar = function () {\n  console.log(\"bar\");\n};\n```\n\nmain.js\n\n```\nimport { foo, bar } from \"./utils.js\";\n\nconst unused = \"a\";\n\nfoo();\n```\n\nindex.js\n\n```\nconst rollup = require(\"rollup\");\n\nrollup\n  .rollup({\n    entry: \"main.js\",\n  })\n  .then(async (bundle) => {\n    bundle.write({\n      dest: \"bundle.js\",\n    });\n  });\n```\n\n其中，`main.js` 是构建的入口文件，然后 `index.js` 负责使用 Rollup 进行构建，它会将最终的构建结果写入到 `bundle.js` 文件中：\n\n```\n// bundle.js\nconst foo = function () {\n  console.log(\"foo\");\n};\n\nconst unused = \"a\";\n\nfoo();\n```\n\n可以看到，在 `bundle.js` 中**保留了** `utils.js` 中的 `foo()` 函数（因为被调用了），而导入的 `uitls.js` 中的 `bar()` 函数（没有被调用）则 **不会保留** ，并且定义的变量 `ununsed` 虽然没有被使用，但是仍然保留了下来。\n\n所以，通过这么一个小的示例，我们可以验证得知 Rollup 的 Tree-shaking 最初并不支持 DCE，它仅仅 **只是在构建结果中保留你导入的模块中需要的代码** 。\n\n### 2.2 现在的 Tree-shaking\n\n前面，我们从过去的 Tree-shaking 开始了解，大致建立起了对 Tree-shaking 的初印象。这里我们来看一下现在 Rollup 官方上对 [Tree-shaking](https://link.segmentfault.com/?enc=tquxYSLxgo9Yw%2FrINTURPg%3D%3D.jzcCcd0hL%2BjHNHoCwAvIeGJ6%2FMRNRqklb7oci5qCaEmYYPrGt2RSxzoanZDorzvTk%2Fo2rByX7tkt7yPTodRJUQ%3D%3D \"Tree-shaking\") 的介绍：\n\n> Tree-shaking，也被称为 Live Code Inclusion，是指 Rollup 消除项目中实际未使用的代码的过程，它是一种 Dead Code Elimination 的方式，但是在输出方面会比其他方法更有效。该名称源自模块的抽象语法树（Abstract Sytanx Tree）。该算法首先会标记所有相关的语句，然后通过摇动语法树来删除所有的 Dead Code。它在思想上类似于 GC（Garbage Collection）中的标记清除算法。尽管， **该算法不限于 ES Module** ，但它们使其效率更高，因为它允许 Rollup 将所有模块一起视为具有共享绑定的大抽象语法树。\n\n从这段话，我们可以很容易地发现随着时间的推移，Rollup 对 Tree-shaking 的定义已经不仅仅是 ES Module 相关，此外它还支持了 DCE。所以，有时候我们看到一些文章介绍 Tree-shaking 实现会是这样：\n\n* 利用 **ES Module 可以进行静态分析**的特点来检测模块内容的导出、导入以及被使用的情况，保留 Live Code\n* 消除**不会被执行**和**没有副作用（Side Effect）** 的 Dead Code，即 DCE 过程\n\n那么，在前面我们已经知道 Tree-shaking 基于 ES Module 静态分析的特点会做的事情。所以，这里我们来仔细看一下第 2 点，换个角度看，它指的是当代码 **没有被执行** ，但是它会 **存在副作用** ，这个时候 Tree-shaking 就不会把这部分代码消除。\n\n那么，显然对副作用建立良好的认知，可以让项目中代码能更好地被 Tree-shaking。所以，下面让我们来通过一个简单的例子来认识一下副作用。\n\n#### 2.2.1 副作用（Side Effect）\n\n在 Wiki 上对[副作用（Side Effect）](https://link.segmentfault.com/?enc=I%2BsgF6ijTuV2fmvMV8%2FMzw%3D%3D.5laAzty3OfJk8bh7S93itAk1lLGpWsG1q5NyBO52zmELfUpvPWZxjtFw4BydoikR \"副作用（Side Effect）\")做出的介绍：\n\n> 在计算机科学中，如果操作、函数或表达式在其本地环境之外修改某些状态变量值，则称其具有副作用。\n\n把这段话转换成我们熟悉的，它指的是当你修改了**不包含在当前作用域**的某些变量值的时候，则会产生副作用。这里我们把上面的例子稍作修改，把 `sayHi()` 函数的形参删掉，改为直接访问定义好的 `name` 变量：\n\nutils.js\n\n```javascript\nexport const name = \"wjc\";\n\nexport const sayHi = function () {\n  console.log(`Hi ${name}`);\n};\n```\n\nmain.js\n\n```javascript\nimport { sayHi } from \"./maths.js\";\n\nsayHi();\n```\n\n然后，我们把这个例子通过 Rollup 提供的[ REPL](https://link.segmentfault.com/?enc=xrpu8YB821h8Xhk8D%2B56Fg%3D%3D.Lr%2BRX1NGa5n%2F76jKTrdZcstb4PALEzPyhjIpc2TQ1QA%3D \"REPL\") 来 Tree-shaking 一下，输出的结果会是这样：\n\n```javascript\nconst name = \"wjc\";\n\nconst sayHi = function () {\n  console.log(`Hi ${name}`);\n};\n\nsayHi();\n```\n\n可以看到，这里我们并没有直接导入 `utils.js` 文件中的 `name` 变量，但是由于在 `sayHi()` 函数中访问了它作用域之外的变量 `name`，产生了副作用，所以最后输出的结果也会有 `name` 变量。\n\n当然，这仅仅只是一个非常简单的产生副作用的场景，也是很多同学不会犯的错误。此外，一个很有趣的场景就是使用 `Class` 关键字声明的类经过 Babel 转换为 ES5 的代码（为了保证 `Class` 可枚举）后会产生副作用。\n\n> 对上面提到的这个问题感兴趣的同学，可以看这篇文章 [你的 Tree-Shaking 并没什么用](https://link.segmentfault.com/?enc=alIevwDquWyYBjENmlL5aA%3D%3D.GpBYLIBHNWWW%2B2w4N9nJmnIzFygC0cWc2vI91jLQtukhG39zXuuNgtaJQjH%2FoxEF \"你的 Tree-Shaking 并没什么用\") 仔细了解，这里就不做重复论述了\n\n# 结语\n\n通过对比 2015 年 Rich Harris 在提出 Tree-shaking 的初衷，到现在 Tree-shaking 所具备的能力来说，随着时间的演变 Rollup 的 Tree-shaking 默认也支持了 DCE，这也难免会造成一些人（包括我）对 Tree-shaking 的理解产生混乱。所以，如果想要追溯本源（Tree-shaking 由来），推荐仔细阅读一下《Tree-shaking versus dead code elimination》这篇文章。\n","tags":["前端"]},{"title":"Vue重学计划（一）","url":"/2024/10/06/Vue重学计划（一）/","content":"~~经过了很久的深思熟虑~~，突然就决定重新学一下Vue3了，这一次准备往更底层的方面研究一下，第一期就简单聊聊Vue的宏观架构方面的二次认知吧！（~~其实只是太懒罢了~~）\n\n# 来自MVVM的伟力\n\n后端大多是MVC架构来写CURD，前端也有个架构，MVVM。最早接触MVVM是做.NET 8 的WPF项目的时候，那时候年少轻狂，妄想把MVC那一套套用在前端上，最后还是无奈求助网友，得知了MVVM这个用来绑定view（视图）和model（数据）的架构。\n\nMVVM（Model-View-ViewModel）架构：\n\n1. 『View』：视图层（UI 用户界面）\n2. 『ViewModel』：业务逻辑层（一切 js 可视为业务逻辑）\n3. 『Model』：数据层（存储数据及对数据的处理如增删改查）\n\n![1728313215762](Vue重学计划（一）/1728313215762.png)\n\n除了MVC和MVVM，我在做游戏开发的时候还接触过ECS架构，这种架构与Unity的组织架构如出一辙，在实体上绑定组件，交互让系统来提供，对于交互性和实时性非常强的游戏开发来说，ECS是非常有效的一种架构。\n\n# 响应式数据绑定\n\n在vue2中，实现双向数据绑定基于Object.defineProperties()实现\n\n而在vue3中，响应式的数据绑定采用了基于Proxy的拦截\n\nVue 2 使用 getter / setters 完全是出于支持旧版本浏览器的限制。而在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter / setter 用于 ref。\n\n这里面的实现涉及到包括但不限于状态机、信号处理等知识，可以参考[深入响应式系统 | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/extras/reactivity-in-depth.html)深入了解，这里就只简单聊聊：\n\n```javascript\nvue2\n基于Object.defineProperty()实现\n \nvue3 基于Proxy\nproxy与Object.defineProperty(obj, prop, desc)方式相比有以下优势：\n \n//丢掉麻烦的备份数据\n//省去for in 循环\n//可以监听数组变化\n//代码更简化\n//可以监听动态新增的属性；\n//可以监听删除的属性 ；\n//可以监听数组的索引和 length 属性；\n \n    let proxyObj = new Proxy(obj,{\n        get : function (target,prop) {\n            return prop in target ? target[prop] : 0\n        },\n        set : function (target,prop,value) {\n            target[prop] = 888;\n        }\n    })\n```\n\n# 虚拟DOM的优化\n\n**在Vue2中,每次更新diff,都是全量对比,Vue3则只对比带有标记的,这样大大减少了非动态内容的对比消耗**\n\n[Vue Template Explorer](https://vue-next-template-explorer.netlify.app/ \"Vue Template Explorer\") 我们可以通过这个网站看到静态标记\n\npatch flag 优化静态树\n\n```html\n <span>Hello world!</span>\n<span>Hello world!</span>\n<span>Hello world!</span>\n<span>Hello world!</span>\n<span>{{msg}}</span>\n<span>Hello world!</span>\n<span>Hello world! </span>\n```\n\nVue3 编译后的 Vdom 是这个样子的\n\n```javascript\nexport function render(_ctx，_cache，props，props，setup，data，data，options){return (_openBlock(),_createBlock(_Fragment,null，[\n_createvNode( \"span\", null,\"Hello world ! \"),\n_createvNode( \"span\",null，\"Hello world! \"),\n_createvNode( \"span\"，null，\"Hello world! \"),\n_createvNode( \"span\", null，\"Hello world! \"),\n_createVNode(\"span\", null，_toDisplaystring(_ctx.msg)，1/* TEXT */)，\n_createvNode( \"span\", null，\"Hello world! \"),\n_createvNode( \"span\", null，\"Hello world! \")]，64/*STABLE_FRAGMENT */))\n```\n\n新增了 patch flag 标记\n\n```javascript\nTEXT = 1 // 动态文本节点\nCLASS=1<<1,1 // 2//动态class\nSTYLE=1<<2，// 4 //动态style\nPROPS=1<<3,// 8 //动态属性，但不包含类名和样式\nFULLPR0PS=1<<4,// 16 //具有动态key属性，当key改变时，需要进行完整的diff比较。\nHYDRATE_ EVENTS = 1 << 5，// 32 //带有监听事件的节点\nSTABLE FRAGMENT = 1 << 6, // 64 //一个不会改变子节点顺序的fragment\nKEYED_ FRAGMENT = 1 << 7, // 128 //带有key属性的fragment 或部分子字节有key\nUNKEYED FRAGMENT = 1<< 8, // 256 //子节点没有key 的fragment\nNEED PATCH = 1 << 9, // 512 //一个节点只会进行非props比较\nDYNAMIC_SLOTS = 1 << 10 // 1024 // 动态slot\nHOISTED = -1 // 静态节点\nBALL = -2\n```\n\n我们发现创建动态 dom 元素的时候，Vdom 除了模拟出来了它的基本信息之外，还给它加了一个标记： 1 /* TEXT */\n\n这个标记就叫做 patch flag（补丁标记）\n\npatch flag 的强大之处在于，当你的 diff 算法走到 _createBlock 函数的时候，会忽略所有的静态节点，只对有标记的动态节点进行对比，而且在多层的嵌套下依然有效。\n\n尽管 JavaScript 做 Vdom 的对比已经非常的快，但是 patch flag 的出现还是让 Vue3 的 Vdom 的性能得到了很大的提升，尤其是在针对大组件的时候。\n\n# 应用TreeShaking的打包\n\n简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码\n\n在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到\n\n而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果你不使用其某些功能，它们将不会包含在你的基础包中\n\n就是比如你要用watch 就是import {watch} from 'vue' 其他的computed 没用到就不会给你打包减少体积\n\n**具体可以参考我的其他博客**\n\n# 组合式API\n\n之前看到有人喷后端Spring仔是配置文件高手，其实我想说，Vue2的写法也很像在写配置文件，可能鱿鱼须当年也认为这样子分块会使得代码很有条理吧。\n\n![API-COMP](https://user-images.githubusercontent.com/499550/62783026-810e6180-ba89-11e9-8774-e7771c8095d6.png)\n\n确实，条理是有了，代码量和代码逻辑变得更加复杂了，所以我个人是更喜欢Vue3的组合式api的写法的.\n\n组合式API除了带来响应式API，更多的是提供了生命周期钩子和依赖注入，这有点类似于Unity的C#脚本，也许这种前端的工作本就应该朝着这样的方向进化和发展？\n","tags":["前端"],"categories":["Vue3重学计划"]},{"title":"Hello Stranger!","url":"/2024/09/26/hello-Stranger/","content":"# 欢迎来到我的博客！\n\n这里将记录我的学习笔记、生活感悟以及一些技术分享。\n\n希望你可以找到你的技术支持，抑或你的人生启蒙。\n\n> **戏里繁华，戏外江山。**\n>\n> **曲高莫忧人不识，几字流年和清辞。**\n"}]