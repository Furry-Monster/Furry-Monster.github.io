<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>Java新特性日志——Java 8 - Furry Monster的博客</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="Java新特性日志——Java 8 - Furry Monster的博客" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="http://furry-monster.github.io/2024/10/16/Java%E6%96%B0%E7%89%B9%E6%80%A7%E6%97%A5%E5%BF%97%E2%80%94%E2%80%94Java%208/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2024-10-16T02:47:27.000Z" />
  
  <meta property="og:article:author" content="FurryMonster" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
    <body
        data-color-scheme="dark"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/Furry-Monster" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="/" target="_blank" aria-label="CodePen">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="/" target="_blank" aria-label="Patreon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-mastodon nav-item-icon" href="/" target="_blank" aria-label="Mastodon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-discord nav-item-icon" href="/" target="_blank" aria-label="Discord">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        
        <div class="categories text-uppercase">
        
            <a href="/categories/Java新特性日志/">Java新特性日志</a>
        
        </div>
        

        
        <div class="date" id="date">
            <span>October</span>
            <span>16,</span>
            <span>2024</span>
        </div>
        

        <h1 class="title">Java新特性日志——Java 8</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <p>这几天忙着处理留学的一些事情，博客断更了几天，今天重新启动！</p>
<p>感觉自己快要被多方势力撕裂了，每天都在被不同的建议和思想折磨。。。原本清晰的目标却一天天地模糊了。闲暇时间，读了读汤显祖的《牡丹亭》，文言文也啃不动，只觉得大脑去思考那些文字，比被乱七八糟的思想折磨要舒服。</p>
<p>这几天忙，也没学什么新知识，干脆做个新特性日志，以后当个Log查查好了，还能有点意义。</p>
<h1 id="Java长期支持版本（LTS）"><a href="#Java长期支持版本（LTS）" class="headerlink" title="Java长期支持版本（LTS）"></a>Java长期支持版本（LTS）</h1><p>经常用Java的同学都知道，Java经过数十年的发展，版本的选择也成了一个难题。</p>
<blockquote>
<p>Java 现在发布的版本很快，每年两个，但是真正会被大规模使用的是 3 年一个的 LTS 版本。</p>
</blockquote>
<ul>
<li>每 3 年发布一个 LTS（Long-Term Support），长期维护版本。意味着只有 <strong>Java 8 ，Java 11， Java 17，Java 21 才可能被大规模使用</strong> 。</li>
<li>每年发布两个正式版本，分别是 3 月份和 9 月份。</li>
</ul>
<p>而我们开发的时候，关注Java 8和Java 17这两个节点就可以了，因为Java 8引入很多非常实用的新特性，而Java 17对Spring框架提供了基本的支持，其他版本的话就视项目和个人喜好而定了。</p>
<h1 id="Java-8为啥这么出名"><a href="#Java-8为啥这么出名" class="headerlink" title="Java 8为啥这么出名"></a>Java 8为啥这么出名</h1><p>相信很多初学JavaSE的同学，使用的第一个版本就是Java 8，甚至很多面试的同学，在简历上写“熟悉Java 8特性”可以成为一个加分项。这就离不开Java 8 的一些新特性了。</p>
<p>一个最主要原因还是商业收费的问题，不过另一个原因就是Java 8出众的新特性：</p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在Java 8之前，我们的匿名内部类是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//新建一个线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;   </span><br><span class="line">	<span class="comment">//创建一个实现Runnable的匿名内部类</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;   </span><br><span class="line">	    <span class="comment">//具体的实现逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Java 8的Lambda表达式，可以简写成这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//新建一个线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);  <span class="comment">//Lambda方法实现</span></span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它的底层其实并不只是简简单单的语法糖替换，而是通过 <code>invokedynamic</code>指令实现的，不难发现，匿名内部类会在编译时创建一个单独的class文件，但是lambda却不会，间接说明编译之后lambda并不是以匿名内部类的形式存在的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();   </span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，实际上是Main类中的 <code>lambda$main$0()</code>方法抛出的异常，但是我们的Main类中压根没有这个方法，很明显是自动生成的。所以，与其说Lambda是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。比如Runnable接口需要一个方法体对它的 <code>run()</code>方法进行实现，而这里我们就通过lambda的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给JVM去处理就好了。</p>
</blockquote>
<p>Lambda表达式的具体规范：</p>
<ul>
<li>格式：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li>
<li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li>
<li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li>
</ul>
<h3 id="方法引用与函数式接口"><a href="#方法引用与函数式接口" class="headerlink" title="方法引用与函数式接口"></a>方法引用与函数式接口</h3><p>Lambda表达式的另一个用法是直接引用，可以认为是一种<strong>方法****引用</strong>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> Main::impl;    <span class="comment">//使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">impl</span><span class="params">(Integer i)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是已经存在的实现&quot;</span>+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义：<strong>方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。</strong></p>
</blockquote>
<p>常见的方法引用有三种：</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>格式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>引用静态方法</td>
<td><code>类名::静态方法名</code></td>
</tr>
<tr>
<td>引用对象的实例方法</td>
<td><code>实例对象::方法名</code></td>
</tr>
<tr>
<td>引用类型的任意对象的实例方法</td>
<td><code>类名::实例方法名</code></td>
</tr>
</tbody></table>
<p>事实上，Lambda 能够简化的一个依据就是函数式接口。</p>
<p>函数式接口是一个只有一个抽象方法的接口，最开始的时候也叫做 <strong>SAM 类型</strong>的接口（<code>Single Abstract Method</code>）。它具有两个特点：</p>
<ol>
<li><strong>只包含一个抽象方法</strong> ：函数式接口只能有一个抽象方法，但可以包含多个默认方法或静态方法。</li>
<li><strong>用</strong> <strong><code>@FunctionalInterface</code></strong> <strong>注解标记</strong> ：该注解不强制，但通常会使用它来标记该接口为函数式接口。这样做可以让编译器检查接口是否符合函数式接口的定义，以避免不必要的错误。</li>
</ol>
<p>所以， 从本质上来说 <strong>Lambda 表达式就是一个函数式接口的实例</strong> 。这就是 Lambda 表达式和函数式接口的关系。简单理解就是只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示。</p>
<p>下面给出一个纯函数式接口的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FunctionInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认方法：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FunctionInterface</span> <span class="variable">functionInterface</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;死磕 Java 就是牛...&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用抽象方法</span></span><br><span class="line">functionInterface.doSomething();</span><br><span class="line"><span class="comment">// 调用默认方法</span></span><br><span class="line">functionInterface.defaultMethod(<span class="string">&quot;死磕 Netty 就是牛...&quot;</span>);</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">FunctionInterface.staticMethod(<span class="string">&quot;死磕 Java 并发就是牛...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Java 8也为我们提供了一些内置的函数式接口供我们使用：Consumer、Function、Supplier等，具体可以看这篇博客：<a target="_blank" rel="noopener" href="https://www.skjava.com/series/article/1841959591">Java 8 新特性—函数式接口 - 死磕 Java (skjava.com)</a></p>
<h3 id="Optional解决空指针问题"><a href="#Optional解决空指针问题" class="headerlink" title="Optional解决空指针问题"></a>Optional解决空指针问题</h3><p>Java 8中新引入了Optional特性，来让我们更优雅的处理空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String str)</span>&#123;   <span class="comment">//现在我们要实现一个方法，将传入的字符串转换为小写并打印</span></span><br><span class="line">    System.out.println(str.toLowerCase());  <span class="comment">//那太简单了吧，直接转换打印一气呵成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样实现的话，我们少考虑了一个问题，万一给进来的 <code>str</code>是 <code>null</code>呢？如果是 <code>null</code>的话，在调用 <code>toLowerCase</code>方法时岂不是直接空指针异常了？所以我们还得判空一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(str.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写起来非常难受，思路正在头上的时候，经常会因为处理判空之类的问题，把自己的思路打乱，Optional类就可以解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将str包装进Optional</span></span><br><span class="line">            .ifPresent(s -&gt; &#123;   <span class="comment">//ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void）</span></span><br><span class="line">                System.out.println(s);   </span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看Optional类的Api：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Optional</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果非空，则为该值；如果为空，则表示没有值存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出来，Optional 的本质就是内部存储了一个真实的值 T，如果 T 非空，就为该值，如果为空，则表示该值不存在。</p>
<h3 id="新的日期时间API"><a href="#新的日期时间API" class="headerlink" title="新的日期时间API"></a>新的日期时间API</h3><p>原有的Java日期时间Api有这些问题：</p>
<ol>
<li><strong>线程不安全</strong> ：<code>java.util.Date</code> 和 <code>java.util.Calendar</code> 线程不安全，这就导致我们在多线程环境使用需要额外注意。同时， <code>java.text.SimpleDateFormat</code> 也是线程不安全的，这可能导致性能问题和日期格式化错误。而且它的模式字符串容易出错，且不够直观。</li>
<li><strong>可变性</strong> ：<code>java.util.Date</code>类是可变的，这意味着我们可以随时修改它，如果一不小心就会导致数据不一致问题。</li>
<li><strong>时区处理困难</strong> ：Java 8 版本以前的日期 API 在时区处理上存在问题，例如时区转换和夏令时处理不够灵活和准确。而且时区信息在 <code>Date</code> 对象中存储不明确，这使得正确处理时区变得复杂。</li>
<li><strong>设计不佳</strong> ：日期和日期格式化分布在多个包中。<code>java.util.Date</code> 的默认日期，年竟然是从 1900 开始，月从 1 开始，日从 1 开始，没有统一性。而且 <code>java.util.Date</code> 类也缺少直接操作日期的相关方法。日期和时间处理通常需要大量的样板代码，使得代码变得冗长和难以维护。</li>
</ol>
<p>相比 Java 8 之前的版本，Java 8 版本的日期时间 API 具有如下几个优点：</p>
<ol>
<li><strong>不可变性（Immutability）</strong> ：Java 8的日期时间类（如 <code>LocalDate</code>、<code>LocalTime</code>和 <code>LocalDateTime</code>）都是不可变的，一旦创建就不能被修改。这确保了 <strong>线程安全</strong> ，避免了并发问题。</li>
<li><strong>清晰的API设计</strong> ：Java 8 的日期时间 API 采用了更清晰、更一致的设计，相比于以前版本的 <code>Date</code> 和 <code>Calendar</code> 更易于理解和使用。而且它们还提供了丰富的方法来执行日期和时间的各种操作，如加减、比较、格式化等。</li>
<li><strong>本地化支持</strong> ：Java 8 的日期时间 API 支持本地化，可以轻松处理不同地区和语言的日期和时间格式。它们能够自动适应不同的时区和夏令时规则。</li>
<li><strong>新的时区处理</strong> ：Java 8引入了 <code>ZoneId</code> 和 <code>ZoneOffset</code> 等新的时区类，使时区处理更加精确和灵活。这有助于解决以前版本中时区处理的问题。</li>
<li><strong>新的格式化API</strong> ：Java 8引入了 <code>DateTimeFormatter</code> 类，用于格式化和解析日期和时间，支持自定义格式和本地化。这提供了更强大和灵活的格式化选项。</li>
<li><strong>更好的性能</strong> ：Java 8 的日期时间API 比以前的API 性能更佳。</li>
</ol>
<h3 id="Stream-API-对元素流进行函数式操作"><a href="#Stream-API-对元素流进行函数式操作" class="headerlink" title="Stream API 对元素流进行函数式操作"></a>Stream API 对元素流进行函数式操作</h3><p>Java 8 中两个最为重要的的更新：第一个是 <a target="_blank" rel="noopener" href="https://www.skjava.com/series/article/1747461365">Lambda 表达式</a>，另外一个就是 <code>Stream API</code></p>
<p><code>Stream API</code> 是 Java 8 引入的一个用于对集合数据进行函数式编程操作的强大的库。它允许我们以一种更简洁、易读、高效的方式来处理集合数据，可以极大提高 Java 程序员的生产力，是目前为止对 Java 类库最好的补充。</p>
<p><code>Stream API</code> 的核心思想是将数据处理操作以函数式的方式链式连接，以便于执行各种操作，如过滤、映射、排序、归约等，而无需显式编写传统的循环代码。</p>
<p>相比各种for循环，StreamAPI在CRUD技巧上实现了函数式编程，关注计算而非数据本身.</p>
<p>一个完整的 Stream 操作包括三步</p>
<h4 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h4><p>首先我们需要一个 Stream 对象，常见的创建方式有：</p>
<ul>
<li>使用集合的 <code>stream()</code> 方法</li>
</ul>
<p>在集合中有两个方法可以创建 Stream 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span>：返回一个顺序流</span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">parallelStream</span><span class="params">()</span>：返回一个并行流</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>通过数组</li>
</ul>
<p><code>Arrays.stream(T[] array)</code>，将数组转换为 Stream 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Java 并发&quot;</span>,<span class="string">&quot;Java 虚拟机&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(array);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>Stream.of(T... values)</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Java 并发&quot;</span>,<span class="string">&quot;Java 虚拟机&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方式适用于直接提供一组元素来创建Stream。</p>
<ul>
<li>使用 <code>Stream.builder()</code>方法</li>
</ul>
<p>Stream 提供了一个 <code>builder()</code> 方法来提供构建 Stream 的构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class="line">builder.accept(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">builder.accept(<span class="string">&quot;Java 并发&quot;</span>);</span><br><span class="line">builder.accept(<span class="string">&quot;Java 虚拟机&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = builder.build();</span><br></pre></td></tr></table></figure>

<p>这种方式适用于需要逐个添加元素到Stream中的情况。</p>
<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>有了 Stream 对象，就可以在 Stream 上应用中间操作。</p>
<p>中间操作是一系列的操作，对数据源的数据进行处理，例如过滤、映射、排序、去重等等。注意这些操作不会立即执行，而是构建一个操作链。下表是 Stream 中常用中间操作方法。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>filter(Predicate&lt;T&gt; predicate)</code></td>
<td>根据给定的谓词条件过滤元素。</td>
</tr>
<tr>
<td><code>map(Function&lt;T, R&gt; mapper)</code></td>
<td>将元素通过给定的函数映射为另一个类型的元素。</td>
</tr>
<tr>
<td><code>flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper)</code></td>
<td>将每个元素映射为一个流，然后将这些流合并为一个流。</td>
</tr>
<tr>
<td><code>distinct()</code></td>
<td>去除流中的重复元素。</td>
</tr>
<tr>
<td><code>sorted()</code></td>
<td>对元素进行排序，默认按自然顺序排序。</td>
</tr>
<tr>
<td><code>sorted(Comparator&lt;T&gt; comparator)</code></td>
<td>使用自定义比较器对元素进行排序。</td>
</tr>
<tr>
<td><code>limit(long maxSize)</code></td>
<td>截取流中的前 maxSize 个元素。</td>
</tr>
<tr>
<td><code>skip(long n)</code></td>
<td>跳过流中的前N个元素。</td>
</tr>
</tbody></table>
<h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>做完中间操作后，我们需要调用一个终端操作来触发实际的数据处理。终端操作会遍历 Stream 并执行中间操作并产生结果。下表是一些常见的终端操作方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>forEach()</code></td>
<td>对流中的每个元素执行指定的操作。</td>
</tr>
<tr>
<td><code>forEachOrdered()</code></td>
<td>与forEach类似，但保留了元素的顺序。</td>
</tr>
<tr>
<td><code>toArray()</code></td>
<td>将流中的元素收集到数组中。</td>
</tr>
<tr>
<td><code>reduce(accumulator)</code></td>
<td>通过累积操作将流中的元素归约为单个结果。</td>
</tr>
<tr>
<td><code>reduce(identity, accumulator)</code></td>
<td>使用初始值和累积操作将流中的元素归约为单个结果。</td>
</tr>
<tr>
<td><code>reduce(identity, accumulator, combiner)</code></td>
<td>使用初始值、累积操作和组合操作将流中的元素归约为单个结果。</td>
</tr>
<tr>
<td><code>collect()</code></td>
<td>将流中的元素收集到集合或映射中，可以指定收集器来定制收集行为。</td>
</tr>
<tr>
<td><code>min(comparator)</code></td>
<td>使用指定的比较器找到流中的最小元素。</td>
</tr>
<tr>
<td><code>max(comparator)</code></td>
<td>使用指定的比较器找到流中的最大元素。</td>
</tr>
<tr>
<td><code>count()</code></td>
<td>计算流中元素的数量。</td>
</tr>
<tr>
<td><code>anyMatch()</code></td>
<td>检查流中是否有任何元素匹配指定的条件。</td>
</tr>
<tr>
<td><code>allMatch()</code></td>
<td>检查流中的所有元素是否都匹配指定的条件。</td>
</tr>
<tr>
<td><code>noneMatch()</code></td>
<td>检查流中是否没有元素匹配指定的条件。</td>
</tr>
<tr>
<td><code>findFirst()</code></td>
<td>返回流中的第一个元素（如果存在），通常与filter操作一起使用。</td>
</tr>
<tr>
<td><code>findAny()</code></td>
<td>返回流中的任意元素（如果存在），通常与filter操作一起使用。</td>
</tr>
</tbody></table>
<h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><p>除了上面介绍的主要特性（尤其是StreamAPI和）之外，Java 8的新特性还包括：</p>
<ul>
<li>日期格式化</li>
<li>构造器引用</li>
<li>重复注解@Repeatable</li>
<li>异步类CompletableFuture</li>
<li>类型注解</li>
<li>接口默认方法与静态方法</li>
<li>类型推断优化</li>
<li>Base64 API</li>
</ul>
<p>这些新特性在平时开发中也不用可以去学，时间长了自然会用上，总而言之，Java 8还是主要去掌握Stream API和Lambda函数式编程为要。</p>

    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by FurryMonster, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
        <p class="tags">
            
            <i class="icon"></i>
            <a href="/tags/编程语言/" class="tag">#编程语言</a>
        </p>
        
    </div>
    

    <div class="container post-prev-next">
        
        <a href="/2024/10/16/Vue%E9%87%8D%E5%AD%A6%E8%AE%A1%E5%88%92%EF%BC%88%E5%85%AD%EF%BC%89/" class="next">
            <div>
                <div class="text">
                    <p class="label">Next</p>
                    <h3 class="title">Vue重学计划（六）</h3>
                </div>
            </div>
        </a>
        
        
        <a href="/2024/10/12/Sass%E5%85%A5%E9%97%A8%E5%88%9D%E6%AD%A5/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">Sass入门初步</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/resume" class="item">Resume</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/Furry-Monster/YouOnlyLockOncev1.0" class="item">YouOnlyLockOnce</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/Furry-Monster" class="item">GitHub</a>
                
                <a href="" class="item">CodePen</a>
                
                <a href="" class="item">Patreon</a>
                
                <a href="" class="item">Mastodon</a>
                
                <a href="" class="item">Discord</a>
                
            </div>
            
        </div>
        <span>&copy; 2025 FurryMonster<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>